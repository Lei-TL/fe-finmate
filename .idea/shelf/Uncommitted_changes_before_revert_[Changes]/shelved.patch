Index: app/src/main/java/com/finmate/ui/activities/FriendActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.finmate.ui.activities;\r\n\r\nimport android.content.Intent;\r\nimport android.os.Bundle;\r\nimport android.view.View;\r\nimport android.widget.TextView;\r\n\r\nimport androidx.recyclerview.widget.LinearLayoutManager;\r\nimport androidx.recyclerview.widget.RecyclerView;\r\n\r\nimport com.finmate.R;\r\nimport com.finmate.ui.friend.FriendUIModel;\r\nimport com.finmate.ui.friend.FriendAdapter;\r\nimport com.google.android.material.bottomnavigation.BottomNavigationView;\r\nimport com.finmate.ui.base.BaseActivity;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\npublic class FriendActivity extends BaseActivity {\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_friend);\r\n\r\n        // Nút Back\r\n        findViewById(R.id.btnBack).setOnClickListener(v -> finish());\r\n\r\n        // RecyclerView\r\n        RecyclerView rvFriends = findViewById(R.id.rvFriends);\r\n        rvFriends.setLayoutManager(new LinearLayoutManager(this));\r\n\r\n        // Sample data\r\n        List<FriendUIModel> friendList = new ArrayList<>();\r\n        friendList.add(new FriendUIModel(\"1\", \"user1\", \"Nguyễn An\", \"nguyenan@example.com\", \"ACCEPTED\", false));\r\n        friendList.add(new FriendUIModel(\"2\", \"user2\", \"Nguyễn Văn B\", \"nguyenvanb@example.com\", \"ACCEPTED\", false));\r\n        friendList.add(new FriendUIModel(\"3\", \"user3\", \"Trần Thị C\", \"tranthic@example.com\", \"ACCEPTED\", false));\r\n        friendList.add(new FriendUIModel(\"4\", \"user4\", \"Lê Văn D\", \"levand@example.com\", \"PENDING\", true));\r\n        friendList.add(new FriendUIModel(\"5\", \"user5\", \"Phạm Thị E\", \"phamthie@example.com\", \"ACCEPTED\", false));\r\n\r\n        FriendAdapter adapter = new FriendAdapter(friendList);\r\n        rvFriends.setAdapter(adapter);\r\n\r\n        // Setup empty state\r\n        View layoutEmptyState = findViewById(R.id.layoutEmptyState);\r\n        if (layoutEmptyState != null) {\r\n            TextView tvEmptyTitle = layoutEmptyState.findViewById(R.id.tvEmptyTitle);\r\n            TextView tvEmptyHint = layoutEmptyState.findViewById(R.id.tvEmptyHint);\r\n            if (tvEmptyTitle != null) {\r\n                tvEmptyTitle.setText(R.string.no_friends);\r\n            }\r\n            if (tvEmptyHint != null) {\r\n                tvEmptyHint.setText(R.string.no_friends_hint);\r\n            }\r\n\r\n            // Show/hide empty state based on data\r\n            if (friendList.isEmpty()) {\r\n                layoutEmptyState.setVisibility(View.VISIBLE);\r\n                rvFriends.setVisibility(View.GONE);\r\n            } else {\r\n                layoutEmptyState.setVisibility(View.GONE);\r\n                rvFriends.setVisibility(View.VISIBLE);\r\n            }\r\n        }\r\n\r\n        // Connect New Friend Button\r\n        android.widget.Button btnConnectNewFriend = findViewById(R.id.btnConnectNewFriend);\r\n        if (btnConnectNewFriend != null) {\r\n            btnConnectNewFriend.setOnClickListener(v -> showConnectFriendDialog());\r\n        }\r\n\r\n        // Bottom Navigation\r\n        BottomNavigationView bottomNav = findViewById(R.id.bottomNavigation);\r\n        bottomNav.setSelectedItemId(R.id.nav_settings);\r\n\r\n        bottomNav.setOnItemSelectedListener(item -> {\r\n            int id = item.getItemId();\r\n            Intent intent = null;\r\n\r\n            if (id == R.id.nav_home) {\r\n                intent = new Intent(this, com.finmate.ui.home.HomeActivity.class);\r\n            } else if (id == R.id.nav_wallet) {\r\n                intent = new Intent(this, com.finmate.ui.home.WalletActivity.class);\r\n            } else if (id == R.id.nav_add) {\r\n                intent = new Intent(this, AddTransactionActivity.class);\r\n            } else if (id == R.id.nav_statistic) {\r\n                intent = new Intent(this, StatisticActivity.class);\r\n            } else if (id == R.id.nav_settings) {\r\n                return true; // Đang ở Settings (FriendActivity là sub-screen của Settings), không cần navigate\r\n            }\r\n\r\n            if (intent != null) {\r\n                startActivity(intent);\r\n                overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);\r\n            }\r\n            return true;\r\n        });\r\n    }\r\n    \r\n    private void showConnectFriendDialog() {\r\n        android.app.AlertDialog.Builder builder = new android.app.AlertDialog.Builder(this);\r\n        builder.setTitle(R.string.connect_new_friend);\r\n        \r\n        // Create input field\r\n        final android.widget.EditText input = new android.widget.EditText(this);\r\n        input.setHint(R.string.email_or_friend_name);\r\n        input.setInputType(android.text.InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);\r\n        builder.setView(input);\r\n        \r\n        builder.setPositiveButton(R.string.connect, (dialog, which) -> {\r\n            String emailOrName = input.getText().toString().trim();\r\n            if (emailOrName.isEmpty()) {\r\n                android.widget.Toast.makeText(this, R.string.fill_all_info, android.widget.Toast.LENGTH_SHORT).show();\r\n                return;\r\n            }\r\n            // TODO: Call API to send friend request\r\n            android.widget.Toast.makeText(this, \"Đã gửi lời mời kết bạn đến \" + emailOrName, android.widget.Toast.LENGTH_SHORT).show();\r\n        });\r\n        \r\n        builder.setNegativeButton(R.string.cancel, null);\r\n        builder.show();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/finmate/ui/activities/FriendActivity.java b/app/src/main/java/com/finmate/ui/activities/FriendActivity.java
--- a/app/src/main/java/com/finmate/ui/activities/FriendActivity.java	(revision 156bc616bb4c3d046268d7f0400bef81621c2927)
+++ b/app/src/main/java/com/finmate/ui/activities/FriendActivity.java	(date 1765524617422)
@@ -4,45 +4,66 @@
 import android.os.Bundle;
 import android.view.View;
 import android.widget.TextView;
+import android.widget.Toast;
 
+import androidx.lifecycle.ViewModelProvider;
 import androidx.recyclerview.widget.LinearLayoutManager;
 import androidx.recyclerview.widget.RecyclerView;
 
 import com.finmate.R;
 import com.finmate.ui.friend.FriendUIModel;
 import com.finmate.ui.friend.FriendAdapter;
+import com.finmate.ui.friend.FriendViewModel;
 import com.google.android.material.bottomnavigation.BottomNavigationView;
 import com.finmate.ui.base.BaseActivity;
 
 import java.util.ArrayList;
 import java.util.List;
 
+import dagger.hilt.android.AndroidEntryPoint;
+
+@AndroidEntryPoint
 public class FriendActivity extends BaseActivity {
 
+    private FriendViewModel viewModel;
+
+    private RecyclerView rvFriends;
+    private FriendAdapter adapter;
+
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_friend);
 
+        viewModel = new ViewModelProvider(this).get(FriendViewModel.class);
+
         // Nút Back
         findViewById(R.id.btnBack).setOnClickListener(v -> finish());
 
         // RecyclerView
-        RecyclerView rvFriends = findViewById(R.id.rvFriends);
+        rvFriends = findViewById(R.id.rvFriends);
         rvFriends.setLayoutManager(new LinearLayoutManager(this));
 
-        // Sample data
-        List<FriendUIModel> friendList = new ArrayList<>();
-        friendList.add(new FriendUIModel("1", "user1", "Nguyễn An", "nguyenan@example.com", "ACCEPTED", false));
-        friendList.add(new FriendUIModel("2", "user2", "Nguyễn Văn B", "nguyenvanb@example.com", "ACCEPTED", false));
-        friendList.add(new FriendUIModel("3", "user3", "Trần Thị C", "tranthic@example.com", "ACCEPTED", false));
-        friendList.add(new FriendUIModel("4", "user4", "Lê Văn D", "levand@example.com", "PENDING", true));
-        friendList.add(new FriendUIModel("5", "user5", "Phạm Thị E", "phamthie@example.com", "ACCEPTED", false));
-
-        FriendAdapter adapter = new FriendAdapter(friendList);
+        adapter = new FriendAdapter(new ArrayList<>());
         rvFriends.setAdapter(adapter);
+        
+        observeViewModel();
+        setupActions();
 
         // Setup empty state
+        setupEmptyState();
+        
+        // Connect New Friend Button
+        setupConnectFriendButton();
+
+        // Bottom Navigation
+        setupBottomNavigation();
+
+        // Load friends data
+        viewModel.loadFriends();
+    }
+
+    private void setupEmptyState() {
         View layoutEmptyState = findViewById(R.id.layoutEmptyState);
         if (layoutEmptyState != null) {
             TextView tvEmptyTitle = layoutEmptyState.findViewById(R.id.tvEmptyTitle);
@@ -53,49 +74,95 @@
             if (tvEmptyHint != null) {
                 tvEmptyHint.setText(R.string.no_friends_hint);
             }
-
-            // Show/hide empty state based on data
-            if (friendList.isEmpty()) {
-                layoutEmptyState.setVisibility(View.VISIBLE);
-                rvFriends.setVisibility(View.GONE);
-            } else {
-                layoutEmptyState.setVisibility(View.GONE);
-                rvFriends.setVisibility(View.VISIBLE);
-            }
-        }
+        }
+    }
 
-        // Connect New Friend Button
+    private void setupConnectFriendButton() {
         android.widget.Button btnConnectNewFriend = findViewById(R.id.btnConnectNewFriend);
         if (btnConnectNewFriend != null) {
             btnConnectNewFriend.setOnClickListener(v -> showConnectFriendDialog());
         }
+    }
 
-        // Bottom Navigation
+    private void setupBottomNavigation() {
         BottomNavigationView bottomNav = findViewById(R.id.bottomNavigation);
-        bottomNav.setSelectedItemId(R.id.nav_settings);
+        if (bottomNav != null) {
+            bottomNav.setSelectedItemId(R.id.nav_settings);
 
-        bottomNav.setOnItemSelectedListener(item -> {
-            int id = item.getItemId();
-            Intent intent = null;
+            bottomNav.setOnItemSelectedListener(item -> {
+                int id = item.getItemId();
+                Intent intent = null;
 
-            if (id == R.id.nav_home) {
-                intent = new Intent(this, com.finmate.ui.home.HomeActivity.class);
-            } else if (id == R.id.nav_wallet) {
-                intent = new Intent(this, com.finmate.ui.home.WalletActivity.class);
-            } else if (id == R.id.nav_add) {
-                intent = new Intent(this, AddTransactionActivity.class);
-            } else if (id == R.id.nav_statistic) {
-                intent = new Intent(this, StatisticActivity.class);
-            } else if (id == R.id.nav_settings) {
-                return true; // Đang ở Settings (FriendActivity là sub-screen của Settings), không cần navigate
-            }
+                if (id == R.id.nav_home) {
+                    intent = new Intent(this, com.finmate.ui.home.HomeActivity.class);
+                } else if (id == R.id.nav_wallet) {
+                    intent = new Intent(this, com.finmate.ui.home.WalletActivity.class);
+                } else if (id == R.id.nav_add) {
+                    intent = new Intent(this, AddTransactionActivity.class);
+                } else if (id == R.id.nav_statistic) {
+                    intent = new Intent(this, StatisticActivity.class);
+                } else if (id == R.id.nav_settings) {
+                    return true; // Đang ở Settings (FriendActivity là sub-screen của Settings), không cần navigate
+                }
 
-            if (intent != null) {
-                startActivity(intent);
-                overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);
-            }
-            return true;
-        });
+                if (intent != null) {
+                    startActivity(intent);
+                    overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);
+                }
+                return true;
+            });
+        }
+    }
+
+    private void observeViewModel() {
+        viewModel.friends.observe(this, friendList -> {
+            if (adapter != null) {
+                adapter.updateData(friendList != null ? friendList : new ArrayList<>());
+            }
+
+            // Show/hide empty state based on data
+            View layoutEmptyState = findViewById(R.id.layoutEmptyState);
+            if (layoutEmptyState != null && rvFriends != null) {
+                if (friendList == null || friendList.isEmpty()) {
+                    layoutEmptyState.setVisibility(View.VISIBLE);
+                    rvFriends.setVisibility(View.GONE);
+                } else {
+                    layoutEmptyState.setVisibility(View.GONE);
+                    rvFriends.setVisibility(View.VISIBLE);
+                }
+            }
+        });
+
+        viewModel.loading.observe(this, isLoading -> {
+            // Show/hide progress indicator if needed
+        });
+
+        viewModel.error.observe(this, error -> {
+            if (error != null && !error.isEmpty()) {
+                Toast.makeText(this, error, Toast.LENGTH_SHORT).show();
+            }
+        });
+    }
+
+    private void setupActions() {
+        if (adapter != null) {
+            adapter.setOnActionListener(new FriendAdapter.OnActionListener() {
+                @Override
+                public void onRemove(FriendUIModel item) {
+                    viewModel.remove(item.getFriendshipId());
+                }
+
+                @Override
+                public void onAccept(FriendUIModel item) {
+                    viewModel.accept(item.getFriendshipId());
+                }
+
+                @Override
+                public void onReject(FriendUIModel item) {
+                    viewModel.reject(item.getFriendshipId());
+                }
+            });
+        }
     }
     
     private void showConnectFriendDialog() {
@@ -111,11 +178,11 @@
         builder.setPositiveButton(R.string.connect, (dialog, which) -> {
             String emailOrName = input.getText().toString().trim();
             if (emailOrName.isEmpty()) {
-                android.widget.Toast.makeText(this, R.string.fill_all_info, android.widget.Toast.LENGTH_SHORT).show();
+                Toast.makeText(this, R.string.fill_all_info, Toast.LENGTH_SHORT).show();
                 return;
             }
-            // TODO: Call API to send friend request
-            android.widget.Toast.makeText(this, "Đã gửi lời mời kết bạn đến " + emailOrName, android.widget.Toast.LENGTH_SHORT).show();
+            // Call API to send friend request via ViewModel
+            viewModel.sendRequest(emailOrName);
         });
         
         builder.setNegativeButton(R.string.cancel, null);
Index: app/src/main/java/com/finmate/ui/activities/StatisticActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.finmate.ui.activities;\r\n\r\nimport android.content.Context;\r\nimport android.content.Intent;\r\nimport android.graphics.Color;\r\nimport android.os.Bundle;\r\nimport android.widget.ImageView;\r\nimport android.widget.TextView;\r\nimport android.widget.Toast;\r\n\r\nimport androidx.appcompat.app.AppCompatActivity;\r\n\r\nimport com.finmate.R;\r\nimport com.finmate.core.ui.LocaleHelper;\r\nimport com.finmate.data.local.database.entity.TransactionEntity;\r\nimport com.finmate.data.local.database.entity.WalletEntity;\r\nimport com.finmate.data.repository.TransactionRepository;\r\nimport com.finmate.data.repository.WalletRepository;\r\nimport com.finmate.ui.home.WalletActivity;\r\nimport com.github.mikephil.charting.charts.BarChart;\r\nimport com.github.mikephil.charting.charts.PieChart;\r\nimport com.github.mikephil.charting.components.Legend;\r\nimport com.github.mikephil.charting.components.XAxis;\r\nimport com.github.mikephil.charting.data.BarData;\r\nimport com.github.mikephil.charting.data.BarDataSet;\r\nimport com.github.mikephil.charting.data.BarEntry;\r\nimport com.github.mikephil.charting.data.PieData;\r\nimport com.github.mikephil.charting.data.PieDataSet;\r\nimport com.github.mikephil.charting.data.PieEntry;\r\nimport com.github.mikephil.charting.formatter.IndexAxisValueFormatter;\r\nimport com.google.android.material.bottomnavigation.BottomNavigationView;\r\n\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.ArrayList;\r\nimport java.util.Calendar;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Locale;\r\nimport java.util.Map;\r\n\r\nimport javax.inject.Inject;\r\n\r\nimport dagger.hilt.android.AndroidEntryPoint;\r\n\r\n@AndroidEntryPoint\r\npublic class StatisticActivity extends AppCompatActivity {\r\n\r\n    @Override\r\n    protected void attachBaseContext(Context newBase) {\r\n        super.attachBaseContext(LocaleHelper.applyLocale(newBase));\r\n    }\r\n\r\n    @Inject\r\n    TransactionRepository transactionRepository;\r\n    \r\n    @Inject\r\n    WalletRepository walletRepository;\r\n\r\n    ImageView btnBack;\r\n    TextView tvExpenseTab, tvIncomeTab, tvTotalExpense;\r\n    \r\n    // Filter views\r\n    com.google.android.material.chip.Chip chipWalletFilter;\r\n    com.google.android.material.button.MaterialButton btnTimeFilter;\r\n\r\n    BarChart barChartExpense;\r\n    PieChart pieChartExpense;\r\n\r\n    BottomNavigationView bottomNavigation;\r\n    \r\n    // Filter state\r\n    private String selectedWalletName = null; // null = all wallets\r\n    private Long startDateFilter = null;\r\n    private Long endDateFilter = null;\r\n    private List<WalletEntity> wallets = new ArrayList<>();\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_statistic);\r\n\r\n        // ÁNH XẠ\r\n        btnBack = findViewById(R.id.btnBack);\r\n        tvExpenseTab = findViewById(R.id.tvExpenseTab);\r\n        tvIncomeTab = findViewById(R.id.tvIncomeTab);\r\n        tvTotalExpense = findViewById(R.id.tvTotalExpense);\r\n        \r\n        // Filter views\r\n        chipWalletFilter = findViewById(R.id.chipWalletFilter);\r\n        btnTimeFilter = findViewById(R.id.btnTimeFilter);\r\n\r\n        barChartExpense = findViewById(R.id.barChartExpense);\r\n        pieChartExpense = findViewById(R.id.pieChartExpense);\r\n\r\n        bottomNavigation = findViewById(R.id.bottomNavigation);\r\n        \r\n        setupFilters();\r\n\r\n        // BACK\r\n        btnBack.setOnClickListener(v -> finish());\r\n\r\n        // TAB CHI TIÊU (hiện tại)\r\n        tvExpenseTab.setOnClickListener(v -> {});\r\n\r\n        // CHUYỂN QUA THU NHẬP\r\n        tvIncomeTab.setOnClickListener(v -> {\r\n            startActivity(new Intent(this, IncomeStatisticActivity.class));\r\n            overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);\r\n        });\r\n\r\n        // HIGHLIGHT TAB\r\n        highlightTabs();\r\n\r\n        // BOTTOM NAV\r\n        setupBottomNav();\r\n        \r\n        // ✅ Load wallets và transactions\r\n        loadWallets();\r\n        loadTransactions();\r\n    }\r\n    \r\n    private void setupFilters() {\r\n        // Wallet filter\r\n        if (chipWalletFilter != null) {\r\n            chipWalletFilter.setOnClickListener(v -> {\r\n                showWalletSelectionDialog();\r\n            });\r\n        }\r\n        \r\n        // Time filter\r\n        if (btnTimeFilter != null) {\r\n            btnTimeFilter.setOnClickListener(v -> {\r\n                com.finmate.ui.dialogs.TimeFilterBottomSheet bottomSheet = \r\n                    com.finmate.ui.dialogs.TimeFilterBottomSheet.newInstance();\r\n                bottomSheet.setListener(new com.finmate.ui.dialogs.TimeFilterBottomSheet.TimeFilterListener() {\r\n                    @Override\r\n                    public void onTodaySelected() {\r\n                        Calendar today = Calendar.getInstance();\r\n                        today.set(Calendar.HOUR_OF_DAY, 0);\r\n                        today.set(Calendar.MINUTE, 0);\r\n                        today.set(Calendar.SECOND, 0);\r\n                        today.set(Calendar.MILLISECOND, 0);\r\n                        startDateFilter = today.getTimeInMillis();\r\n                        endDateFilter = today.getTimeInMillis() + 86400000 - 1; // End of day\r\n                        btnTimeFilter.setText(getString(R.string.today));\r\n                        loadTransactions();\r\n                    }\r\n\r\n                    @Override\r\n                    public void onSingleDaySelected(java.util.Date date) {\r\n                        Calendar cal = Calendar.getInstance();\r\n                        cal.setTime(date);\r\n                        cal.set(Calendar.HOUR_OF_DAY, 0);\r\n                        cal.set(Calendar.MINUTE, 0);\r\n                        cal.set(Calendar.SECOND, 0);\r\n                        cal.set(Calendar.MILLISECOND, 0);\r\n                        startDateFilter = cal.getTimeInMillis();\r\n                        endDateFilter = cal.getTimeInMillis() + 86400000 - 1;\r\n                        java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat(\"dd/MM/yyyy\", java.util.Locale.getDefault());\r\n                        btnTimeFilter.setText(sdf.format(date));\r\n                        loadTransactions();\r\n                    }\r\n\r\n                    @Override\r\n                    public void onDateRangeSelected(java.util.Date startDate, java.util.Date endDate) {\r\n                        Calendar startCal = Calendar.getInstance();\r\n                        startCal.setTime(startDate);\r\n                        startCal.set(Calendar.HOUR_OF_DAY, 0);\r\n                        startCal.set(Calendar.MINUTE, 0);\r\n                        startCal.set(Calendar.SECOND, 0);\r\n                        startCal.set(Calendar.MILLISECOND, 0);\r\n                        startDateFilter = startCal.getTimeInMillis();\r\n                        \r\n                        Calendar endCal = Calendar.getInstance();\r\n                        endCal.setTime(endDate);\r\n                        endCal.set(Calendar.HOUR_OF_DAY, 23);\r\n                        endCal.set(Calendar.MINUTE, 59);\r\n                        endCal.set(Calendar.SECOND, 59);\r\n                        endCal.set(Calendar.MILLISECOND, 999);\r\n                        endDateFilter = endCal.getTimeInMillis();\r\n                        \r\n                        java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat(\"dd/MM/yyyy\", java.util.Locale.getDefault());\r\n                        btnTimeFilter.setText(sdf.format(startDate) + \" - \" + sdf.format(endDate));\r\n                        loadTransactions();\r\n                    }\r\n\r\n                    @Override\r\n                    public void onClear() {\r\n                        startDateFilter = null;\r\n                        endDateFilter = null;\r\n                        btnTimeFilter.setText(getString(R.string.this_month));\r\n                        loadTransactions();\r\n                    }\r\n                });\r\n                bottomSheet.show(getSupportFragmentManager(), \"TimeFilterBottomSheet\");\r\n            });\r\n        }\r\n    }\r\n    \r\n    private void showWalletSelectionDialog() {\r\n        if (wallets.isEmpty()) {\r\n            Toast.makeText(this, \"Chưa có ví nào\", Toast.LENGTH_SHORT).show();\r\n            return;\r\n        }\r\n        \r\n        String[] walletNames = new String[wallets.size() + 1];\r\n        walletNames[0] = \"Tất cả ví\";\r\n        for (int i = 0; i < wallets.size(); i++) {\r\n            walletNames[i + 1] = wallets.get(i).name;\r\n        }\r\n        \r\n        new androidx.appcompat.app.AlertDialog.Builder(this)\r\n            .setTitle(\"Chọn ví\")\r\n            .setItems(walletNames, (dialog, which) -> {\r\n                if (which == 0) {\r\n                    selectedWalletName = null;\r\n                    chipWalletFilter.setText(\"Tất cả ví\");\r\n                } else {\r\n                    selectedWalletName = wallets.get(which - 1).name;\r\n                    chipWalletFilter.setText(selectedWalletName);\r\n                }\r\n                loadTransactions();\r\n            })\r\n            .show();\r\n    }\r\n    \r\n    private void loadWallets() {\r\n        walletRepository.getAll(new WalletRepository.Callback() {\r\n            @Override\r\n            public void onResult(List<WalletEntity> walletList) {\r\n                wallets = walletList != null ? walletList : new ArrayList<>();\r\n            }\r\n        });\r\n    }\r\n    \r\n    private void loadTransactions() {\r\n        if (selectedWalletName != null) {\r\n            transactionRepository.getByWalletNameAndDateRange(\r\n                selectedWalletName, startDateFilter, endDateFilter,\r\n                new TransactionRepository.OnResultCallback<List<TransactionEntity>>() {\r\n                    @Override\r\n                    public void onResult(List<TransactionEntity> transactions) {\r\n                        processTransactions(transactions);\r\n                    }\r\n                }\r\n            );\r\n        } else {\r\n            transactionRepository.getByDateRange(\r\n                startDateFilter, endDateFilter,\r\n                new TransactionRepository.OnResultCallback<List<TransactionEntity>>() {\r\n                    @Override\r\n                    public void onResult(List<TransactionEntity> transactions) {\r\n                        processTransactions(transactions);\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    }\r\n    \r\n    private void processTransactions(List<TransactionEntity> transactions) {\r\n        if (transactions == null) {\r\n            transactions = new ArrayList<>();\r\n        }\r\n        \r\n        // Filter chỉ EXPENSE\r\n        List<TransactionEntity> expenseTransactions = new ArrayList<>();\r\n        double totalExpense = 0;\r\n        for (TransactionEntity t : transactions) {\r\n            if (t.type != null && t.type.equals(\"EXPENSE\")) {\r\n                expenseTransactions.add(t);\r\n                totalExpense += t.amountDouble;\r\n            }\r\n        }\r\n        \r\n        // Update total expense\r\n        if (tvTotalExpense != null) {\r\n            tvTotalExpense.setText(formatAmount(totalExpense));\r\n        }\r\n        \r\n        // Load charts\r\n        loadBarChartData(expenseTransactions);\r\n        loadPieChartData(expenseTransactions);\r\n    }\r\n    \r\n    private String formatAmount(double amount) {\r\n        if (amount >= 1_000_000_000) {\r\n            return String.format(Locale.getDefault(), \"%,.1fB\", amount / 1_000_000_000);\r\n        } else if (amount >= 1_000_000) {\r\n            return String.format(Locale.getDefault(), \"%,.1fM\", amount / 1_000_000);\r\n        } else if (amount >= 1_000) {\r\n            return String.format(Locale.getDefault(), \"%,.1fK\", amount / 1_000);\r\n        } else {\r\n            return String.format(Locale.getDefault(), \"%,.0f\", amount);\r\n        }\r\n    }\r\n\r\n    // ===================== BAR CHART =====================\r\n    private void loadBarChartData(List<TransactionEntity> transactions) {\r\n        if (transactions == null || transactions.isEmpty()) {\r\n            barChartExpense.clear();\r\n            barChartExpense.setNoDataText(\"Không có dữ liệu\");\r\n            barChartExpense.invalidate();\r\n            return;\r\n        }\r\n\r\n        // Group by month\r\n        Map<String, Double> monthlyData = new HashMap<>();\r\n        Calendar cal = Calendar.getInstance();\r\n        SimpleDateFormat monthFormat = new SimpleDateFormat(\"yyyy-MM\", Locale.getDefault());\r\n        \r\n        for (TransactionEntity t : transactions) {\r\n            if (t.date != null && !t.date.isEmpty()) {\r\n                try {\r\n                    SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\", Locale.getDefault());\r\n                    cal.setTime(dateFormat.parse(t.date));\r\n                    String monthKey = monthFormat.format(cal.getTime());\r\n                    monthlyData.put(monthKey, monthlyData.getOrDefault(monthKey, 0.0) + t.amountDouble);\r\n                } catch (Exception e) {\r\n                    // Skip invalid dates\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (monthlyData.isEmpty()) {\r\n            barChartExpense.clear();\r\n            barChartExpense.setNoDataText(\"Không có dữ liệu\");\r\n            barChartExpense.invalidate();\r\n            return;\r\n        }\r\n        \r\n        // Sort by month and create entries\r\n        List<String> sortedMonths = new ArrayList<>(monthlyData.keySet());\r\n        java.util.Collections.sort(sortedMonths);\r\n        \r\n        List<BarEntry> entries = new ArrayList<>();\r\n        List<String> labels = new ArrayList<>();\r\n        \r\n        for (int i = 0; i < sortedMonths.size(); i++) {\r\n            String month = sortedMonths.get(i);\r\n            entries.add(new BarEntry(i, monthlyData.get(month).floatValue()));\r\n            \r\n            // Format label: \"MM/yyyy\"\r\n            try {\r\n                SimpleDateFormat inputFormat = new SimpleDateFormat(\"yyyy-MM\", Locale.getDefault());\r\n                SimpleDateFormat outputFormat = new SimpleDateFormat(\"MM/yyyy\", Locale.getDefault());\r\n                labels.add(outputFormat.format(inputFormat.parse(month)));\r\n            } catch (Exception e) {\r\n                labels.add(month);\r\n            }\r\n        }\r\n\r\n        BarDataSet dataSet = new BarDataSet(entries, \"Chi tiêu\");\r\n        dataSet.setColor(Color.parseColor(\"#FF5252\"));\r\n        dataSet.setValueTextColor(Color.WHITE);\r\n        dataSet.setValueTextSize(10f);\r\n\r\n        BarData barData = new BarData(dataSet);\r\n        barData.setBarWidth(0.4f);\r\n\r\n        barChartExpense.setData(barData);\r\n        barChartExpense.setFitBars(true);\r\n        barChartExpense.setNoDataText(\"Không có dữ liệu\");\r\n        barChartExpense.getDescription().setEnabled(false);\r\n        barChartExpense.getLegend().setEnabled(false);\r\n\r\n        XAxis xAxis = barChartExpense.getXAxis();\r\n        xAxis.setPosition(XAxis.XAxisPosition.BOTTOM);\r\n        xAxis.setTextColor(Color.WHITE);\r\n        xAxis.setDrawGridLines(false);\r\n        xAxis.setValueFormatter(new IndexAxisValueFormatter(labels));\r\n        xAxis.setLabelCount(labels.size(), true);\r\n\r\n        barChartExpense.animateY(800);\r\n        barChartExpense.invalidate();\r\n    }\r\n\r\n    // ===================== PIE CHART =====================\r\n    private void loadPieChartData(List<TransactionEntity> transactions) {\r\n        if (transactions == null || transactions.isEmpty()) {\r\n            pieChartExpense.clear();\r\n            pieChartExpense.setNoDataText(\"Không có dữ liệu\");\r\n            pieChartExpense.invalidate();\r\n            return;\r\n        }\r\n\r\n        // Group by category\r\n        Map<String, Double> categoryData = new HashMap<>();\r\n        for (TransactionEntity t : transactions) {\r\n            String category = (t.category != null && !t.category.isEmpty()) ? t.category : \"Khác\";\r\n            categoryData.put(category, categoryData.getOrDefault(category, 0.0) + t.amountDouble);\r\n        }\r\n        \r\n        if (categoryData.isEmpty()) {\r\n            pieChartExpense.clear();\r\n            pieChartExpense.setNoDataText(\"Không có dữ liệu\");\r\n            pieChartExpense.invalidate();\r\n            return;\r\n        }\r\n        \r\n        // Sort by amount (descending) and create entries\r\n        List<Map.Entry<String, Double>> sortedCategories = new ArrayList<>(categoryData.entrySet());\r\n        sortedCategories.sort((a, b) -> Double.compare(b.getValue(), a.getValue()));\r\n        \r\n        List<PieEntry> entries = new ArrayList<>();\r\n        int[] colors = {\r\n            Color.parseColor(\"#FF5252\"),\r\n            Color.parseColor(\"#FF8A65\"),\r\n            Color.parseColor(\"#FF7043\"),\r\n            Color.parseColor(\"#FFB74D\"),\r\n            Color.parseColor(\"#FFA726\"),\r\n            Color.parseColor(\"#FF9800\"),\r\n            Color.parseColor(\"#FB8C00\"),\r\n            Color.parseColor(\"#F57C00\")\r\n        };\r\n        \r\n        for (int i = 0; i < sortedCategories.size() && i < 8; i++) {\r\n            Map.Entry<String, Double> entry = sortedCategories.get(i);\r\n            entries.add(new PieEntry(entry.getValue().floatValue(), entry.getKey()));\r\n        }\r\n\r\n        PieDataSet dataSet = new PieDataSet(entries, \"\");\r\n        dataSet.setColors(colors);\r\n        dataSet.setValueTextSize(12f);\r\n        dataSet.setValueTextColor(Color.WHITE);\r\n\r\n        PieData pieData = new PieData(dataSet);\r\n\r\n        pieChartExpense.setData(pieData);\r\n        pieChartExpense.setUsePercentValues(true);\r\n\r\n        pieChartExpense.setTransparentCircleRadius(50f);\r\n        pieChartExpense.setHoleRadius(45f);\r\n\r\n        pieChartExpense.getDescription().setEnabled(false);\r\n\r\n        Legend legend = pieChartExpense.getLegend();\r\n        legend.setTextColor(Color.WHITE);\r\n        legend.setTextSize(12f);\r\n\r\n        pieChartExpense.animateY(800);\r\n        pieChartExpense.invalidate();\r\n    }\r\n\r\n    // ===================== HIGHLIGHT TAB =====================\r\n    private void highlightTabs() {\r\n        // Chi tiêu ACTIVE\r\n        tvExpenseTab.setTextColor(Color.WHITE);\r\n        tvExpenseTab.setTextSize(18f);\r\n        tvExpenseTab.setTypeface(tvExpenseTab.getTypeface(), android.graphics.Typeface.BOLD);\r\n\r\n        // Thu nhập INACTIVE\r\n        tvIncomeTab.setTextColor(Color.parseColor(\"#777777\"));\r\n        tvIncomeTab.setTypeface(tvIncomeTab.getTypeface(), android.graphics.Typeface.NORMAL);\r\n    }\r\n\r\n    // ===================== BOTTOM NAV =====================\r\n    private void setupBottomNav() {\r\n        bottomNavigation.setSelectedItemId(R.id.nav_statistic);\r\n\r\n        bottomNavigation.setOnItemSelectedListener(item -> {\r\n            int id = item.getItemId();\r\n            Intent intent = null;\r\n\r\n            if (id == R.id.nav_home) {\r\n                intent = new Intent(this, com.finmate.ui.home.HomeActivity.class);\r\n            } else if (id == R.id.nav_wallet) {\r\n                intent = new Intent(this, com.finmate.ui.home.WalletActivity.class);\r\n            } else if (id == R.id.nav_add) {\r\n                intent = new Intent(this, AddTransactionActivity.class);\r\n            } else if (id == R.id.nav_statistic) {\r\n                return true; // Đang ở Statistic, không cần navigate\r\n            } else if (id == R.id.nav_settings) {\r\n                intent = new Intent(this, SettingsActivity.class);\r\n            }\r\n\r\n            if (intent != null) {\r\n                startActivity(intent);\r\n                overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);\r\n            }\r\n            return true;\r\n        });\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/finmate/ui/activities/StatisticActivity.java b/app/src/main/java/com/finmate/ui/activities/StatisticActivity.java
--- a/app/src/main/java/com/finmate/ui/activities/StatisticActivity.java	(revision 156bc616bb4c3d046268d7f0400bef81621c2927)
+++ b/app/src/main/java/com/finmate/ui/activities/StatisticActivity.java	(date 1765526559314)
@@ -146,6 +146,77 @@
                         loadTransactions();
                     }
 
+                    @Override
+                    public void on7DaysAgoSelected() {
+                        Calendar end = Calendar.getInstance();
+                        end.set(Calendar.HOUR_OF_DAY, 23);
+                        end.set(Calendar.MINUTE, 59);
+                        end.set(Calendar.SECOND, 59);
+                        end.set(Calendar.MILLISECOND, 999);
+                        endDateFilter = end.getTimeInMillis();
+                        
+                        Calendar start = Calendar.getInstance();
+                        start.add(Calendar.DAY_OF_YEAR, -6);
+                        start.set(Calendar.HOUR_OF_DAY, 0);
+                        start.set(Calendar.MINUTE, 0);
+                        start.set(Calendar.SECOND, 0);
+                        start.set(Calendar.MILLISECOND, 0);
+                        startDateFilter = start.getTimeInMillis();
+                        
+                        btnTimeFilter.setText(getString(R.string.time_filter_7_days));
+                        loadTransactions();
+                    }
+
+                    @Override
+                    public void on1MonthAgoSelected() {
+                        Calendar end = Calendar.getInstance();
+                        end.set(Calendar.HOUR_OF_DAY, 23);
+                        end.set(Calendar.MINUTE, 59);
+                        end.set(Calendar.SECOND, 59);
+                        end.set(Calendar.MILLISECOND, 999);
+                        endDateFilter = end.getTimeInMillis();
+                        
+                        Calendar start = Calendar.getInstance();
+                        start.add(Calendar.MONTH, -1);
+                        start.set(Calendar.HOUR_OF_DAY, 0);
+                        start.set(Calendar.MINUTE, 0);
+                        start.set(Calendar.SECOND, 0);
+                        start.set(Calendar.MILLISECOND, 0);
+                        startDateFilter = start.getTimeInMillis();
+                        
+                        btnTimeFilter.setText(getString(R.string.time_filter_1_month));
+                        loadTransactions();
+                    }
+
+                    @Override
+                    public void on6MonthsAgoSelected() {
+                        Calendar end = Calendar.getInstance();
+                        end.set(Calendar.HOUR_OF_DAY, 23);
+                        end.set(Calendar.MINUTE, 59);
+                        end.set(Calendar.SECOND, 59);
+                        end.set(Calendar.MILLISECOND, 999);
+                        endDateFilter = end.getTimeInMillis();
+                        
+                        Calendar start = Calendar.getInstance();
+                        start.add(Calendar.MONTH, -6);
+                        start.set(Calendar.HOUR_OF_DAY, 0);
+                        start.set(Calendar.MINUTE, 0);
+                        start.set(Calendar.SECOND, 0);
+                        start.set(Calendar.MILLISECOND, 0);
+                        startDateFilter = start.getTimeInMillis();
+                        
+                        btnTimeFilter.setText(getString(R.string.time_filter_6_months));
+                        loadTransactions();
+                    }
+
+                    @Override
+                    public void onAllTimeSelected() {
+                        startDateFilter = null;
+                        endDateFilter = null;
+                        btnTimeFilter.setText(getString(R.string.time_filter_all_time));
+                        loadTransactions();
+                    }
+
                     @Override
                     public void onSingleDaySelected(java.util.Date date) {
                         Calendar cal = Calendar.getInstance();
@@ -214,10 +285,17 @@
             .setItems(walletNames, (dialog, which) -> {
                 if (which == 0) {
                     selectedWalletName = null;
-                    chipWalletFilter.setText("Tất cả ví");
+                    if (chipWalletFilter != null) {
+                        chipWalletFilter.setText("Tất cả ví");
+                    }
                 } else {
-                    selectedWalletName = wallets.get(which - 1).name;
-                    chipWalletFilter.setText(selectedWalletName);
+                    int walletIndex = which - 1;
+                    if (walletIndex >= 0 && walletIndex < wallets.size()) {
+                        selectedWalletName = wallets.get(walletIndex).name;
+                        if (chipWalletFilter != null) {
+                            chipWalletFilter.setText(selectedWalletName);
+                        }
+                    }
                 }
                 loadTransactions();
             })
@@ -337,7 +415,10 @@
         
         for (int i = 0; i < sortedMonths.size(); i++) {
             String month = sortedMonths.get(i);
-            entries.add(new BarEntry(i, monthlyData.get(month).floatValue()));
+            Double value = monthlyData.get(month);
+            if (value != null) {
+                entries.add(new BarEntry(i, value.floatValue()));
+            }
             
             // Format label: "MM/yyyy"
             try {
Index: app/src/main/java/com/finmate/ui/home/HomeViewModel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.finmate.ui.home;\r\n\r\nimport androidx.lifecycle.LiveData;\r\nimport androidx.lifecycle.MutableLiveData;\r\nimport androidx.lifecycle.ViewModel;\r\n\r\nimport com.finmate.data.repository.HomeRepository;\r\nimport com.finmate.data.local.database.entity.TransactionEntity;\r\nimport com.finmate.data.local.database.entity.WalletEntity;\r\n\r\nimport java.util.List;\r\n\r\nimport javax.inject.Inject;\r\n\r\nimport dagger.hilt.android.lifecycle.HiltViewModel;\r\n\r\n@HiltViewModel\r\npublic class HomeViewModel extends ViewModel {\r\n\r\n    private final HomeRepository homeRepository;\r\n\r\n    private final MutableLiveData<List<WalletEntity>> _wallets = new MutableLiveData<>();\r\n    public LiveData<List<WalletEntity>> wallets = _wallets;\r\n\r\n    private final MutableLiveData<List<TransactionEntity>> _transactions = new MutableLiveData<>();\r\n    public LiveData<List<TransactionEntity>> transactions = _transactions;\r\n\r\n    private final MutableLiveData<String> _selectedWalletId = new MutableLiveData<>();\r\n    public LiveData<String> selectedWalletId = _selectedWalletId;\r\n    \r\n    private final MutableLiveData<String> _selectedWalletName = new MutableLiveData<>();\r\n    public LiveData<String> selectedWalletName = _selectedWalletName;\r\n\r\n    // ✅ Time filter state\r\n    private Long timeFilterStartDate = null; // Timestamp in milliseconds\r\n    private Long timeFilterEndDate = null; // Timestamp in milliseconds\r\n\r\n    private final MutableLiveData<Boolean> _isLoading = new MutableLiveData<>();\r\n    public LiveData<Boolean> isLoading = _isLoading;\r\n\r\n    @Inject\r\n    public HomeViewModel(HomeRepository homeRepository) {\r\n        this.homeRepository = homeRepository;\r\n    }\r\n\r\n    public void loadHomeData() {\r\n        _isLoading.postValue(true); // Dùng postValue để an toàn\r\n        homeRepository.fetchWallets(new HomeRepository.DataCallback<List<WalletEntity>>() {\r\n            @Override\r\n            public void onDataLoaded(List<WalletEntity> data) {\r\n                _wallets.postValue(data);\r\n                _isLoading.postValue(false); // ✅ Tắt loading sau khi load xong\r\n                // ✅ Mặc định load tất cả transactions (không filter theo ví)\r\n                selectWallet(null, null); // null = all wallets\r\n            }\r\n\r\n            @Override\r\n            public void onError(String message) {\r\n                _isLoading.postValue(false); // Đảm bảo tắt loading khi có lỗi\r\n                // Xử lý lỗi\r\n            }\r\n        });\r\n    }\r\n\r\n    public void selectWallet(String walletId, String walletName) {\r\n        _selectedWalletId.postValue(walletId); // Dùng postValue để an toàn khi gọi từ background thread\r\n        _selectedWalletName.postValue(walletName);\r\n        loadTransactions(walletId, walletName, timeFilterStartDate, timeFilterEndDate);\r\n    }\r\n    \r\n    // ✅ Overload method để backward compatible\r\n    public void selectWallet(String walletId) {\r\n        selectWallet(walletId, null);\r\n    }\r\n\r\n    // ✅ Select time filter\r\n    public void selectTimeFilter(Long startDate, Long endDate) {\r\n        timeFilterStartDate = startDate;\r\n        timeFilterEndDate = endDate;\r\n        // Reload transactions with new time filter\r\n        String walletId = _selectedWalletId.getValue();\r\n        String walletName = _selectedWalletName.getValue();\r\n        loadTransactions(walletId, walletName, startDate, endDate);\r\n    }\r\n\r\n    private void loadTransactions(String walletId, String walletName) {\r\n        loadTransactions(walletId, walletName, timeFilterStartDate, timeFilterEndDate);\r\n    }\r\n\r\n    private void loadTransactions(String walletId, String walletName, Long startDate, Long endDate) {\r\n        _isLoading.postValue(true); // Dùng postValue để an toàn\r\n        homeRepository.fetchTransactions(walletId, walletName, startDate, endDate, new HomeRepository.DataCallback<List<TransactionEntity>>() {\r\n            @Override\r\n            public void onDataLoaded(List<TransactionEntity> data) {\r\n                _transactions.postValue(data);\r\n                _isLoading.postValue(false);\r\n            }\r\n\r\n            @Override\r\n            public void onError(String message) {\r\n                _isLoading.postValue(false);\r\n                // Xử lý lỗi\r\n            }\r\n        });\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/finmate/ui/home/HomeViewModel.java b/app/src/main/java/com/finmate/ui/home/HomeViewModel.java
--- a/app/src/main/java/com/finmate/ui/home/HomeViewModel.java	(revision 156bc616bb4c3d046268d7f0400bef81621c2927)
+++ b/app/src/main/java/com/finmate/ui/home/HomeViewModel.java	(date 1765527707113)
@@ -50,8 +50,9 @@
             public void onDataLoaded(List<WalletEntity> data) {
                 _wallets.postValue(data);
                 _isLoading.postValue(false); // ✅ Tắt loading sau khi load xong
-                // ✅ Mặc định load tất cả transactions (không filter theo ví)
-                selectWallet(null, null); // null = all wallets
+                // ✅ KHÔNG gọi selectWallet() ở đây nữa
+                // Time filter sẽ được apply từ HomeActivity trong observeViewModel() sau khi wallets được load
+                // Điều này đảm bảo transactions được load với filter đúng ngay từ đầu
             }
 
             @Override
@@ -88,18 +89,22 @@
     }
 
     private void loadTransactions(String walletId, String walletName, Long startDate, Long endDate) {
+        android.util.Log.d("HomeViewModel", "loadTransactions: walletId=" + walletId + ", walletName=" + walletName + ", startDate=" + startDate + ", endDate=" + endDate);
         _isLoading.postValue(true); // Dùng postValue để an toàn
         homeRepository.fetchTransactions(walletId, walletName, startDate, endDate, new HomeRepository.DataCallback<List<TransactionEntity>>() {
             @Override
             public void onDataLoaded(List<TransactionEntity> data) {
+                android.util.Log.d("HomeViewModel", "onDataLoaded: " + (data != null ? data.size() : 0) + " transactions");
                 _transactions.postValue(data);
                 _isLoading.postValue(false);
             }
 
             @Override
             public void onError(String message) {
+                android.util.Log.e("HomeViewModel", "onError: " + message);
                 _isLoading.postValue(false);
-                // Xử lý lỗi
+                // Xử lý lỗi - vẫn post empty list để UI không bị stuck
+                _transactions.postValue(new java.util.ArrayList<>());
             }
         });
     }
Index: app/src/main/java/com/finmate/ui/transaction/TransactionAdapter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.finmate.ui.transaction;\r\n\r\nimport android.content.Context;\r\nimport android.content.res.Resources;\r\nimport android.view.LayoutInflater;\r\nimport android.view.View;\r\nimport android.view.ViewGroup;\r\nimport android.widget.ImageView;\r\nimport android.widget.TextView;\r\n\r\nimport androidx.annotation.NonNull;\r\nimport androidx.core.content.ContextCompat;\r\nimport androidx.recyclerview.widget.RecyclerView;\r\n\r\nimport com.finmate.R;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\npublic class TransactionAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> {\r\n\r\n    private static final int TYPE_HEADER = 0;\r\n    private static final int TYPE_TRANSACTION = 1;\r\n\r\n    private List<TransactionGroupedItem> groupedItems;\r\n    // ✅ Map để cache category name -> icon name\r\n    private Map<String, String> categoryIconMap;\r\n\r\n    public TransactionAdapter(List<TransactionGroupedItem> groupedItems) {\r\n        this.groupedItems = groupedItems;\r\n        this.categoryIconMap = new HashMap<>();\r\n    }\r\n\r\n    // ✅ Set category icon map từ ViewModel/Activity\r\n    public void setCategoryIconMap(Map<String, String> map) {\r\n        this.categoryIconMap = map != null ? new HashMap<>(map) : new HashMap<>();\r\n        // ✅ Notify để refresh tất cả items khi map thay đổi\r\n        notifyDataSetChanged();\r\n    }\r\n\r\n    // === PHƯƠNG THỨC ĐỂ CẬP NHẬT DỮ LIỆU ===\r\n    public void updateList(List<TransactionGroupedItem> newList) {\r\n        this.groupedItems.clear();\r\n        this.groupedItems.addAll(newList);\r\n        notifyDataSetChanged(); // Báo cho RecyclerView cập nhật lại\r\n    }\r\n\r\n    @Override\r\n    public int getItemViewType(int position) {\r\n        return groupedItems.get(position).getType() == TransactionGroupedItem.ItemType.HEADER \r\n                ? TYPE_HEADER \r\n                : TYPE_TRANSACTION;\r\n    }\r\n\r\n    @NonNull\r\n    @Override\r\n    public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {\r\n        if (viewType == TYPE_HEADER) {\r\n            View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_transaction_date_header, parent, false);\r\n            return new DateHeaderViewHolder(view);\r\n        } else {\r\n            View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_transaction, parent, false);\r\n            return new TransactionViewHolder(view);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) {\r\n        TransactionGroupedItem item = groupedItems.get(position);\r\n        \r\n        if (item.getType() == TransactionGroupedItem.ItemType.HEADER) {\r\n            DateHeaderViewHolder headerHolder = (DateHeaderViewHolder) holder;\r\n            headerHolder.tvDate.setText(item.getDateHeader());\r\n            headerHolder.tvDayOfWeek.setText(item.getDayOfWeek());\r\n        } else {\r\n            TransactionViewHolder transactionHolder = (TransactionViewHolder) holder;\r\n            TransactionUIModel transaction = item.getTransaction();\r\n            Context context = holder.itemView.getContext();\r\n            \r\n            transactionHolder.tvName.setText(transaction.getName());\r\n            // ✅ Hiển thị category name (không hiển thị \"Unknown\" nữa)\r\n            String categoryName = transaction.getCategory();\r\n            if (categoryName == null || categoryName.isEmpty()) {\r\n                transactionHolder.tvGroup.setText(\"\");\r\n            } else {\r\n                transactionHolder.tvGroup.setText(categoryName);\r\n            }\r\n            \r\n            // ✅ Lấy icon theo category\r\n            // Logic: categoryName (từ transaction) -> iconName (từ map) -> iconResId (từ drawable)\r\n            String iconName = null;\r\n            if (categoryName != null && !categoryName.isEmpty() && categoryIconMap != null && !categoryIconMap.isEmpty()) {\r\n                // ✅ Thử tìm với tên gốc trước\r\n                iconName = categoryIconMap.get(categoryName);\r\n                // ✅ Nếu không tìm thấy, thử với trimmed\r\n                if (iconName == null) {\r\n                    iconName = categoryIconMap.get(categoryName.trim());\r\n                }\r\n                // ✅ Nếu vẫn không tìm thấy, thử với lowercase\r\n                if (iconName == null) {\r\n                    iconName = categoryIconMap.get(categoryName.toLowerCase());\r\n                }\r\n                // ✅ Nếu vẫn không tìm thấy, thử với trimmed lowercase\r\n                if (iconName == null) {\r\n                    iconName = categoryIconMap.get(categoryName.trim().toLowerCase());\r\n                }\r\n            }\r\n            // ✅ iconName bây giờ là \"ic_food\", \"ic_salary\", etc. (hoặc null)\r\n            int iconResId = getIconResourceId(context, iconName);\r\n            if (iconResId != 0) {\r\n                transactionHolder.imgCategory.setImageResource(iconResId);\r\n                // ✅ Clear tint để hiển thị màu icon gốc\r\n                transactionHolder.imgCategory.setColorFilter(null);\r\n            } else {\r\n                // ✅ Fallback về default icon nếu không tìm thấy\r\n                transactionHolder.imgCategory.setImageResource(R.drawable.ic_default_category);\r\n                transactionHolder.imgCategory.setColorFilter(null);\r\n            }\r\n            \r\n            // ✅ Format amount với dấu + hoặc - và màu sắc dựa trên type\r\n            String type = transaction.getType();\r\n            String amountText = transaction.getAmount();\r\n            \r\n            if (\"INCOME\".equals(type)) {\r\n                // Thu nhập: màu xanh + dấu +\r\n                // Loại bỏ dấu - nếu có, thêm dấu + nếu chưa có\r\n                amountText = amountText.trim();\r\n                if (amountText.startsWith(\"-\")) {\r\n                    amountText = amountText.substring(1); // Bỏ dấu -\r\n                }\r\n                if (!amountText.startsWith(\"+\")) {\r\n                    amountText = \"+\" + amountText;\r\n                }\r\n                transactionHolder.tvMoney.setText(amountText);\r\n                transactionHolder.tvMoney.setTextColor(ContextCompat.getColor(context, R.color.green_500));\r\n            } else if (\"EXPENSE\".equals(type)) {\r\n                // Chi tiêu: màu đỏ + dấu -\r\n                // Loại bỏ dấu + nếu có, thêm dấu - nếu chưa có\r\n                amountText = amountText.trim();\r\n                if (amountText.startsWith(\"+\")) {\r\n                    amountText = amountText.substring(1); // Bỏ dấu +\r\n                }\r\n                if (!amountText.startsWith(\"-\")) {\r\n                    amountText = \"-\" + amountText;\r\n                }\r\n                transactionHolder.tvMoney.setText(amountText);\r\n                transactionHolder.tvMoney.setTextColor(ContextCompat.getColor(context, R.color.red_500));\r\n            } else {\r\n                // TRANSFER hoặc loại khác: giữ nguyên màu mặc định\r\n                transactionHolder.tvMoney.setText(amountText);\r\n                // Sử dụng màu từ layout (textColorPrimary)\r\n                transactionHolder.tvMoney.setTextColor(transactionHolder.tvName.getCurrentTextColor());\r\n            }\r\n            \r\n            transactionHolder.tvWallet.setText(transaction.getWallet());\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getItemCount() {\r\n        return groupedItems.size();\r\n    }\r\n\r\n    // ViewHolder cho Date Header\r\n    public static class DateHeaderViewHolder extends RecyclerView.ViewHolder {\r\n        TextView tvDate, tvDayOfWeek;\r\n\r\n        public DateHeaderViewHolder(@NonNull View itemView) {\r\n            super(itemView);\r\n            tvDate = itemView.findViewById(R.id.tvDate);\r\n            tvDayOfWeek = itemView.findViewById(R.id.tvDayOfWeek);\r\n        }\r\n    }\r\n\r\n    // ✅ Helper method để lấy icon resource ID từ icon name\r\n    // Input: \"ic_food\", \"ic_salary\", etc. (từ categoryIconMap)\r\n    // Output: R.drawable.ic_food, R.drawable.ic_salary, etc.\r\n    private int getIconResourceId(Context context, String iconName) {\r\n        if (iconName == null || iconName.isEmpty()) {\r\n            return 0; // Trả về 0 để adapter dùng default\r\n        }\r\n        \r\n        Resources resources = context.getResources();\r\n        String packageName = context.getPackageName();\r\n        \r\n        // ✅ Icon name từ backend đã là \"ic_food\", chỉ cần trim và tìm\r\n        String trimmedName = iconName.trim();\r\n        int resId = resources.getIdentifier(trimmedName, \"drawable\", packageName);\r\n        \r\n        // ✅ Nếu không tìm thấy (có thể do case), thử lowercase\r\n        if (resId == 0) {\r\n            resId = resources.getIdentifier(trimmedName.toLowerCase(), \"drawable\", packageName);\r\n        }\r\n        \r\n        // Nếu không tìm thấy, trả về 0 để adapter xử lý fallback\r\n        return resId;\r\n    }\r\n\r\n    // ViewHolder cho Transaction\r\n    public static class TransactionViewHolder extends RecyclerView.ViewHolder {\r\n        ImageView imgCategory;\r\n        TextView tvName, tvGroup, tvMoney, tvWallet;\r\n\r\n        public TransactionViewHolder(@NonNull View itemView) {\r\n            super(itemView);\r\n            imgCategory = itemView.findViewById(R.id.imgCategory);\r\n            tvName = itemView.findViewById(R.id.tvName);\r\n            tvGroup = itemView.findViewById(R.id.tvGroup);\r\n            tvMoney = itemView.findViewById(R.id.tvMoney);\r\n            tvWallet = itemView.findViewById(R.id.tvWallet);\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/finmate/ui/transaction/TransactionAdapter.java b/app/src/main/java/com/finmate/ui/transaction/TransactionAdapter.java
--- a/app/src/main/java/com/finmate/ui/transaction/TransactionAdapter.java	(revision 156bc616bb4c3d046268d7f0400bef81621c2927)
+++ b/app/src/main/java/com/finmate/ui/transaction/TransactionAdapter.java	(date 1765517670380)
@@ -48,6 +48,9 @@
 
     @Override
     public int getItemViewType(int position) {
+        if (position < 0 || position >= groupedItems.size()) {
+            return TYPE_TRANSACTION; // Default fallback
+        }
         return groupedItems.get(position).getType() == TransactionGroupedItem.ItemType.HEADER 
                 ? TYPE_HEADER 
                 : TYPE_TRANSACTION;
@@ -67,6 +70,9 @@
 
     @Override
     public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) {
+        if (position < 0 || position >= groupedItems.size()) {
+            return;
+        }
         TransactionGroupedItem item = groupedItems.get(position);
         
         if (item.getType() == TransactionGroupedItem.ItemType.HEADER) {
Index: app/src/main/java/com/finmate/ui/home/WalletActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.finmate.ui.home;\r\n\r\nimport android.content.Intent;\r\nimport android.os.Bundle;\r\nimport android.view.View;\r\nimport android.widget.PopupMenu;\r\nimport android.widget.ProgressBar;\r\nimport android.widget.TextView;\r\nimport android.widget.Toast;\r\n\r\nimport androidx.lifecycle.ViewModelProvider;\r\nimport androidx.recyclerview.widget.LinearLayoutManager;\r\nimport androidx.recyclerview.widget.RecyclerView;\r\n\r\nimport com.finmate.R;\r\nimport com.finmate.data.local.database.entity.TransactionEntity;\r\nimport com.finmate.data.local.database.entity.WalletEntity;\r\nimport com.finmate.ui.activities.AddTransactionActivity;\r\nimport com.finmate.ui.activities.SettingsActivity;\r\nimport com.finmate.ui.activities.StatisticActivity;\r\nimport com.finmate.ui.base.BaseActivity;\r\nimport com.finmate.ui.transaction.TransactionAdapter;\r\nimport com.finmate.ui.transaction.TransactionGroupedItem;\r\nimport com.finmate.ui.transaction.TransactionUIModel;\r\nimport com.finmate.data.repository.CategoryRepository;\r\nimport com.finmate.data.local.database.entity.CategoryEntity;\r\nimport com.google.android.material.bottomnavigation.BottomNavigationView;\r\nimport com.google.android.material.chip.Chip;\r\n\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.ArrayList;\r\nimport java.util.Calendar;\r\nimport java.util.List;\r\nimport java.util.Locale;\r\n\r\nimport dagger.hilt.android.AndroidEntryPoint;\r\n\r\n@AndroidEntryPoint\r\npublic class WalletActivity extends BaseActivity {\r\n\r\n    private WalletViewModel viewModel;\r\n    \r\n    // ✅ CategoryRepository để load categories và lấy icon\r\n    @javax.inject.Inject\r\n    CategoryRepository categoryRepository;\r\n    \r\n    private Chip chipWalletFilter, chipTimeFilter;\r\n    private TextView tvBalance, tvIncomeValue, tvExpenseValue, tvWalletName;\r\n    private ProgressBar progIncome, progExpense;\r\n    private BottomNavigationView bottomNavigation;\r\n    private RecyclerView rvTransactions;\r\n    private TransactionAdapter transactionAdapter;\r\n    private View layoutEmptyState;\r\n    private android.widget.ImageView btnAddTransaction;\r\n    \r\n    private String selectedWalletId = null;\r\n    private String selectedWalletName = \"\";\r\n    \r\n    // ✅ Time filter state\r\n    private Long timeFilterStartDate = null;\r\n    private Long timeFilterEndDate = null;\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_wallet);\r\n\r\n        viewModel = new ViewModelProvider(this).get(WalletViewModel.class);\r\n\r\n        // ÁNH XẠ VIEW\r\n        chipWalletFilter = findViewById(R.id.chipWalletFilter);\r\n        chipTimeFilter = findViewById(R.id.chipTimeFilter);\r\n        tvBalance = findViewById(R.id.tv_balance);\r\n        tvWalletName = findViewById(R.id.tv_wallet_name);\r\n        tvIncomeValue = findViewById(R.id.tv_income_value);\r\n        tvExpenseValue = findViewById(R.id.tv_expense_value);\r\n        btnAddTransaction = findViewById(R.id.btnAddTransaction);\r\n\r\n        progIncome = findViewById(R.id.prog_income);\r\n        progExpense = findViewById(R.id.prog_expense);\r\n\r\n        bottomNavigation = findViewById(R.id.bottomNavigation);\r\n        rvTransactions = findViewById(R.id.rvTransactions);\r\n        layoutEmptyState = findViewById(R.id.layoutEmptyState);\r\n\r\n        // Chọn đúng tab hiện tại\r\n        bottomNavigation.setSelectedItemId(R.id.nav_wallet);\r\n\r\n        setupRecyclerView();\r\n        setupWalletFilter();\r\n        setupTimeFilter();\r\n        setupAddTransactionButton();\r\n        observeViewModel();\r\n        setupBottomNavigation();\r\n        loadCategories(); // ✅ Load categories để lấy icon\r\n        \r\n        viewModel.loadWalletData();\r\n    }\r\n    \r\n    // ✅ Load categories và tạo map categoryName -> iconName\r\n    private void loadCategories() {\r\n        categoryRepository.getAll().observe(this, categories -> {\r\n            if (categories != null && !categories.isEmpty()) {\r\n                java.util.Map<String, String> categoryIconMap = new java.util.HashMap<>();\r\n                for (CategoryEntity category : categories) {\r\n                    if (category.getName() != null && category.getIcon() != null) {\r\n                        String categoryName = category.getName().trim();\r\n                        String iconName = category.getIcon().trim();\r\n                        if (!categoryName.isEmpty() && !iconName.isEmpty()) {\r\n                            categoryIconMap.put(categoryName, iconName);\r\n                            // ✅ Thêm cả lowercase version để match case-insensitive\r\n                            categoryIconMap.put(categoryName.toLowerCase(), iconName);\r\n                        }\r\n                    }\r\n                }\r\n                // ✅ Truyền map vào adapter và notify để refresh\r\n                if (transactionAdapter != null) {\r\n                    transactionAdapter.setCategoryIconMap(categoryIconMap);\r\n                }\r\n            } else {\r\n                // ✅ Nếu chưa có categories, sync từ backend\r\n                categoryRepository.fetchRemoteCategoriesByType(\"INCOME\");\r\n                categoryRepository.fetchRemoteCategoriesByType(\"EXPENSE\");\r\n            }\r\n        });\r\n    }\r\n    \r\n    private void setupRecyclerView() {\r\n        rvTransactions.setLayoutManager(new LinearLayoutManager(this));\r\n        transactionAdapter = new TransactionAdapter(new ArrayList<>());\r\n        rvTransactions.setAdapter(transactionAdapter);\r\n        rvTransactions.setNestedScrollingEnabled(false);\r\n        rvTransactions.setHasFixedSize(false);\r\n    }\r\n\r\n    private void setupWalletFilter() {\r\n        chipWalletFilter.setOnClickListener(v -> showWalletMenu());\r\n    }\r\n    \r\n    private void setupTimeFilter() {\r\n        // ✅ Mặc định: Tháng này\r\n        Calendar cal = Calendar.getInstance();\r\n        cal.set(Calendar.DAY_OF_MONTH, 1);\r\n        cal.set(Calendar.HOUR_OF_DAY, 0);\r\n        cal.set(Calendar.MINUTE, 0);\r\n        cal.set(Calendar.SECOND, 0);\r\n        cal.set(Calendar.MILLISECOND, 0);\r\n        timeFilterStartDate = cal.getTimeInMillis();\r\n        \r\n        cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));\r\n        cal.set(Calendar.HOUR_OF_DAY, 23);\r\n        cal.set(Calendar.MINUTE, 59);\r\n        cal.set(Calendar.SECOND, 59);\r\n        cal.set(Calendar.MILLISECOND, 999);\r\n        timeFilterEndDate = cal.getTimeInMillis();\r\n        \r\n        chipTimeFilter.setText(getString(R.string.this_month));\r\n        \r\n        chipTimeFilter.setOnClickListener(v -> {\r\n            com.finmate.ui.dialogs.TimeFilterBottomSheet bottomSheet = \r\n                com.finmate.ui.dialogs.TimeFilterBottomSheet.newInstance();\r\n            bottomSheet.setListener(new com.finmate.ui.dialogs.TimeFilterBottomSheet.TimeFilterListener() {\r\n                @Override\r\n                public void onTodaySelected() {\r\n                    chipTimeFilter.setText(getString(R.string.today));\r\n                    \r\n                    Calendar cal = Calendar.getInstance();\r\n                    cal.set(Calendar.HOUR_OF_DAY, 0);\r\n                    cal.set(Calendar.MINUTE, 0);\r\n                    cal.set(Calendar.SECOND, 0);\r\n                    cal.set(Calendar.MILLISECOND, 0);\r\n                    timeFilterStartDate = cal.getTimeInMillis();\r\n                    \r\n                    cal.set(Calendar.HOUR_OF_DAY, 23);\r\n                    cal.set(Calendar.MINUTE, 59);\r\n                    cal.set(Calendar.SECOND, 59);\r\n                    cal.set(Calendar.MILLISECOND, 999);\r\n                    timeFilterEndDate = cal.getTimeInMillis();\r\n                    \r\n                    viewModel.selectTimeFilter(timeFilterStartDate, timeFilterEndDate);\r\n                }\r\n\r\n                @Override\r\n                public void onSingleDaySelected(java.util.Date date) {\r\n                    SimpleDateFormat sdf = new SimpleDateFormat(\"dd/MM/yyyy\", Locale.getDefault());\r\n                    String dateText = sdf.format(date);\r\n                    chipTimeFilter.setText(dateText);\r\n                    \r\n                    Calendar cal = Calendar.getInstance();\r\n                    cal.setTime(date);\r\n                    cal.set(Calendar.HOUR_OF_DAY, 0);\r\n                    cal.set(Calendar.MINUTE, 0);\r\n                    cal.set(Calendar.SECOND, 0);\r\n                    cal.set(Calendar.MILLISECOND, 0);\r\n                    timeFilterStartDate = cal.getTimeInMillis();\r\n                    \r\n                    cal.set(Calendar.HOUR_OF_DAY, 23);\r\n                    cal.set(Calendar.MINUTE, 59);\r\n                    cal.set(Calendar.SECOND, 59);\r\n                    cal.set(Calendar.MILLISECOND, 999);\r\n                    timeFilterEndDate = cal.getTimeInMillis();\r\n                    \r\n                    viewModel.selectTimeFilter(timeFilterStartDate, timeFilterEndDate);\r\n                }\r\n\r\n                @Override\r\n                public void onDateRangeSelected(java.util.Date startDate, java.util.Date endDate) {\r\n                    SimpleDateFormat sdf = new SimpleDateFormat(\"dd/MM/yyyy\", Locale.getDefault());\r\n                    String dateText = sdf.format(startDate) + \" - \" + sdf.format(endDate);\r\n                    chipTimeFilter.setText(dateText);\r\n                    \r\n                    Calendar calStart = Calendar.getInstance();\r\n                    calStart.setTime(startDate);\r\n                    calStart.set(Calendar.HOUR_OF_DAY, 0);\r\n                    calStart.set(Calendar.MINUTE, 0);\r\n                    calStart.set(Calendar.SECOND, 0);\r\n                    calStart.set(Calendar.MILLISECOND, 0);\r\n                    timeFilterStartDate = calStart.getTimeInMillis();\r\n                    \r\n                    Calendar calEnd = Calendar.getInstance();\r\n                    calEnd.setTime(endDate);\r\n                    calEnd.set(Calendar.HOUR_OF_DAY, 23);\r\n                    calEnd.set(Calendar.MINUTE, 59);\r\n                    calEnd.set(Calendar.SECOND, 59);\r\n                    calEnd.set(Calendar.MILLISECOND, 999);\r\n                    timeFilterEndDate = calEnd.getTimeInMillis();\r\n                    \r\n                    viewModel.selectTimeFilter(timeFilterStartDate, timeFilterEndDate);\r\n                }\r\n\r\n                @Override\r\n                public void onClear() {\r\n                    chipTimeFilter.setText(getString(R.string.this_month));\r\n                    \r\n                    // Reset về tháng này\r\n                    Calendar cal = Calendar.getInstance();\r\n                    cal.set(Calendar.DAY_OF_MONTH, 1);\r\n                    cal.set(Calendar.HOUR_OF_DAY, 0);\r\n                    cal.set(Calendar.MINUTE, 0);\r\n                    cal.set(Calendar.SECOND, 0);\r\n                    cal.set(Calendar.MILLISECOND, 0);\r\n                    timeFilterStartDate = cal.getTimeInMillis();\r\n                    \r\n                    cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));\r\n                    cal.set(Calendar.HOUR_OF_DAY, 23);\r\n                    cal.set(Calendar.MINUTE, 59);\r\n                    cal.set(Calendar.SECOND, 59);\r\n                    cal.set(Calendar.MILLISECOND, 999);\r\n                    timeFilterEndDate = cal.getTimeInMillis();\r\n                    \r\n                    viewModel.selectTimeFilter(timeFilterStartDate, timeFilterEndDate);\r\n                }\r\n            });\r\n            bottomSheet.show(getSupportFragmentManager(), \"TimeFilterBottomSheet\");\r\n        });\r\n    }\r\n    \r\n    private void setupAddTransactionButton() {\r\n        btnAddTransaction.setOnClickListener(v -> {\r\n            Intent intent = new Intent(this, AddTransactionActivity.class);\r\n            // ✅ Nếu đã chọn ví cụ thể, có thể truyền walletId để pre-select\r\n            if (selectedWalletId != null) {\r\n                intent.putExtra(\"walletId\", selectedWalletId);\r\n            }\r\n            startActivity(intent);\r\n        });\r\n    }\r\n    \r\n    private void showWalletMenu() {\r\n        List<WalletEntity> wallets = viewModel.wallets.getValue();\r\n        \r\n        if (wallets == null || wallets.isEmpty()) {\r\n            Toast.makeText(this, getString(R.string.no_wallets), Toast.LENGTH_SHORT).show();\r\n            return;\r\n        }\r\n\r\n        PopupMenu popupMenu = new PopupMenu(this, chipWalletFilter);\r\n        \r\n        // Thêm \"Tất cả ví\" vào menu\r\n        popupMenu.getMenu().add(0, 0, 0, getString(R.string.all_wallets));\r\n        \r\n        // Thêm các ví từ database vào menu\r\n        for (int i = 0; i < wallets.size(); i++) {\r\n            WalletEntity wallet = wallets.get(i);\r\n            popupMenu.getMenu().add(0, i + 1, i + 1, wallet.name);\r\n        }\r\n        \r\n        popupMenu.setOnMenuItemClickListener(item -> {\r\n            int itemId = item.getItemId();\r\n            \r\n            if (itemId == 0) {\r\n                selectedWalletName = getString(R.string.all_wallets);\r\n                selectedWalletId = null;\r\n                chipWalletFilter.setText(selectedWalletName);\r\n                updateWalletName(selectedWalletName);\r\n                viewModel.selectWallet(null, null);\r\n            } else {\r\n                int walletIndex = itemId - 1;\r\n                if (walletIndex >= 0 && walletIndex < wallets.size()) {\r\n                    WalletEntity selectedWallet = wallets.get(walletIndex);\r\n                    selectedWalletId = selectedWallet.id;\r\n                    selectedWalletName = selectedWallet.name;\r\n                    chipWalletFilter.setText(selectedWalletName);\r\n                    updateWalletName(selectedWalletName);\r\n                    viewModel.selectWallet(selectedWalletId, selectedWalletName);\r\n                }\r\n            }\r\n            return true;\r\n        });\r\n        \r\n        popupMenu.show();\r\n    }\r\n    \r\n    private void observeViewModel() {\r\n        viewModel.wallets.observe(this, wallets -> {\r\n            if (wallets != null && !wallets.isEmpty() && selectedWalletName.isEmpty()) {\r\n                selectedWalletName = getString(R.string.all_wallets);\r\n                selectedWalletId = null;\r\n                chipWalletFilter.setText(selectedWalletName);\r\n                // ✅ Cập nhật tên ví trên card\r\n                updateWalletName(selectedWalletName);\r\n                // ✅ Tự động load transactions cho \"Tất cả ví\" khi wallets được load lần đầu\r\n                viewModel.selectWallet(null, null);\r\n            }\r\n            updateBalance(wallets);\r\n        });\r\n        \r\n        viewModel.transactions.observe(this, transactions -> {\r\n            updateWalletData(transactions);\r\n            updateTransactionList(transactions);\r\n        });\r\n    }\r\n    \r\n    private void updateWalletName(String walletName) {\r\n        if (tvWalletName != null) {\r\n            tvWalletName.setText(walletName);\r\n        }\r\n    }\r\n    \r\n    private void updateTransactionList(List<TransactionEntity> transactionEntities) {\r\n        if (transactionEntities == null || transactionEntities.isEmpty()) {\r\n            if (transactionAdapter != null) {\r\n                transactionAdapter.updateList(new ArrayList<>());\r\n            }\r\n            if (layoutEmptyState != null) {\r\n                layoutEmptyState.setVisibility(View.VISIBLE);\r\n                rvTransactions.setVisibility(View.GONE);\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Group transactions theo ngày\r\n        List<TransactionGroupedItem> groupedItems = groupTransactionsByDate(transactionEntities);\r\n        if (transactionAdapter != null) {\r\n            transactionAdapter.updateList(groupedItems);\r\n        }\r\n        \r\n        if (layoutEmptyState != null) {\r\n            layoutEmptyState.setVisibility(View.GONE);\r\n            rvTransactions.setVisibility(View.VISIBLE);\r\n        }\r\n    }\r\n    \r\n    private List<TransactionGroupedItem> groupTransactionsByDate(List<TransactionEntity> transactions) {\r\n        List<TransactionGroupedItem> groupedItems = new ArrayList<>();\r\n        \r\n        // ✅ Sắp xếp transactions theo date giảm dần (mới nhất lên trên)\r\n        List<TransactionEntity> sortedTransactions = new ArrayList<>(transactions);\r\n        sortedTransactions.sort((t1, t2) -> {\r\n            try {\r\n                SimpleDateFormat isoFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\", Locale.getDefault());\r\n                SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\", Locale.getDefault());\r\n                \r\n                java.util.Date date1 = null, date2 = null;\r\n                try {\r\n                    date1 = isoFormat.parse(t1.date);\r\n                } catch (Exception e) {\r\n                    try {\r\n                        date1 = dateFormat.parse(t1.date);\r\n                    } catch (Exception e2) {\r\n                        return 0;\r\n                    }\r\n                }\r\n                \r\n                try {\r\n                    date2 = isoFormat.parse(t2.date);\r\n                } catch (Exception e) {\r\n                    try {\r\n                        date2 = dateFormat.parse(t2.date);\r\n                    } catch (Exception e2) {\r\n                        return 0;\r\n                    }\r\n                }\r\n                \r\n                // Giảm dần: date2.compareTo(date1)\r\n                return date2.compareTo(date1);\r\n            } catch (Exception e) {\r\n                return 0;\r\n            }\r\n        });\r\n        \r\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\", Locale.getDefault());\r\n        SimpleDateFormat isoFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\", Locale.getDefault());\r\n        SimpleDateFormat displayDateFormat = new SimpleDateFormat(\"dd/MM/yyyy\", Locale.getDefault());\r\n        SimpleDateFormat dayOfWeekFormat = new SimpleDateFormat(\"EEEE\", new Locale(\"vi\", \"VN\"));\r\n        \r\n        // ✅ Calendar để so sánh ngày\r\n        Calendar today = Calendar.getInstance();\r\n        today.set(Calendar.HOUR_OF_DAY, 0);\r\n        today.set(Calendar.MINUTE, 0);\r\n        today.set(Calendar.SECOND, 0);\r\n        today.set(Calendar.MILLISECOND, 0);\r\n        \r\n        Calendar yesterday = Calendar.getInstance();\r\n        yesterday.add(Calendar.DAY_OF_YEAR, -1);\r\n        yesterday.set(Calendar.HOUR_OF_DAY, 0);\r\n        yesterday.set(Calendar.MINUTE, 0);\r\n        yesterday.set(Calendar.SECOND, 0);\r\n        yesterday.set(Calendar.MILLISECOND, 0);\r\n        \r\n        java.util.Map<String, List<TransactionEntity>> transactionsByDate = new java.util.LinkedHashMap<>();\r\n        \r\n        for (TransactionEntity entity : sortedTransactions) {\r\n            if (entity.date == null || entity.date.isEmpty()) continue;\r\n            \r\n            try {\r\n                java.util.Date date;\r\n                try {\r\n                    date = isoFormat.parse(entity.date);\r\n                } catch (Exception e) {\r\n                    date = dateFormat.parse(entity.date);\r\n                }\r\n                \r\n                String dateKey = dateFormat.format(date);\r\n                \r\n                if (!transactionsByDate.containsKey(dateKey)) {\r\n                    transactionsByDate.put(dateKey, new ArrayList<>());\r\n                }\r\n                transactionsByDate.get(dateKey).add(entity);\r\n            } catch (Exception e) {\r\n                // Ignore parse errors\r\n            }\r\n        }\r\n        \r\n        // ✅ Tạo grouped items với header cho mỗi ngày (giữ thứ tự từ LinkedHashMap)\r\n        for (java.util.Map.Entry<String, List<TransactionEntity>> entry : transactionsByDate.entrySet()) {\r\n            String dateKey = entry.getKey();\r\n            List<TransactionEntity> dayTransactions = entry.getValue();\r\n            \r\n            try {\r\n                java.util.Date date = dateFormat.parse(dateKey);\r\n                Calendar dateCal = Calendar.getInstance();\r\n                dateCal.setTime(date);\r\n                dateCal.set(Calendar.HOUR_OF_DAY, 0);\r\n                dateCal.set(Calendar.MINUTE, 0);\r\n                dateCal.set(Calendar.SECOND, 0);\r\n                dateCal.set(Calendar.MILLISECOND, 0);\r\n                \r\n                // ✅ Xác định label: \"Hôm nay\", \"Hôm qua\", hoặc dd/MM/yyyy\r\n                String dateHeader;\r\n                if (isSameDay(dateCal, today)) {\r\n                    dateHeader = getString(R.string.today);\r\n                } else if (isSameDay(dateCal, yesterday)) {\r\n                    dateHeader = getString(R.string.yesterday);\r\n                } else {\r\n                    dateHeader = displayDateFormat.format(date);\r\n                }\r\n                \r\n                String dayOfWeek = formatDayOfWeek(dayOfWeekFormat.format(date));\r\n                \r\n                groupedItems.add(new TransactionGroupedItem(dateHeader, dayOfWeek));\r\n                \r\n                for (TransactionEntity entity : dayTransactions) {\r\n                    TransactionUIModel uiModel = new TransactionUIModel(\r\n                            entity.name,\r\n                            entity.category,\r\n                            entity.amount,\r\n                            entity.wallet,\r\n                            entity.date,\r\n                            entity.type\r\n                    );\r\n                    groupedItems.add(new TransactionGroupedItem(uiModel));\r\n                }\r\n            } catch (Exception e) {\r\n                // Ignore parse errors\r\n            }\r\n        }\r\n        \r\n        return groupedItems;\r\n    }\r\n    \r\n    // ✅ Helper method để so sánh 2 ngày (chỉ so sánh năm/tháng/ngày)\r\n    private boolean isSameDay(Calendar cal1, Calendar cal2) {\r\n        return cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\r\n               cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR);\r\n    }\r\n    \r\n    private String formatDayOfWeek(String dayOfWeek) {\r\n        java.util.Map<String, String> dayMap = new java.util.HashMap<>();\r\n        dayMap.put(\"Monday\", \"Thứ 2\");\r\n        dayMap.put(\"Tuesday\", \"Thứ 3\");\r\n        dayMap.put(\"Wednesday\", \"Thứ 4\");\r\n        dayMap.put(\"Thursday\", \"Thứ 5\");\r\n        dayMap.put(\"Friday\", \"Thứ 6\");\r\n        dayMap.put(\"Saturday\", \"Thứ 7\");\r\n        dayMap.put(\"Sunday\", \"Chủ nhật\");\r\n        \r\n        return dayMap.getOrDefault(dayOfWeek, dayOfWeek);\r\n    }\r\n    \r\n    private void updateBalance(List<WalletEntity> wallets) {\r\n        if (wallets == null || wallets.isEmpty() || tvBalance == null) {\r\n            return;\r\n        }\r\n        \r\n        double totalBalance = 0;\r\n        if (selectedWalletId != null) {\r\n            for (WalletEntity w : wallets) {\r\n                if (w.id.equals(selectedWalletId)) {\r\n                    totalBalance = w.currentBalance;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            for (WalletEntity w : wallets) {\r\n                totalBalance += w.currentBalance;\r\n            }\r\n        }\r\n        tvBalance.setText(formatMoney((long) totalBalance) + \" VND\");\r\n    }\r\n    \r\n    private void updateWalletData(List<TransactionEntity> transactions) {\r\n        if (transactions == null || transactions.isEmpty()) {\r\n            tvIncomeValue.setText(\"+0 VND\");\r\n            tvExpenseValue.setText(\"-0 VND\");\r\n            progIncome.setProgress(0);\r\n            progExpense.setProgress(0);\r\n            return;\r\n        }\r\n        \r\n        double totalIncome = 0;\r\n        double totalExpense = 0;\r\n        \r\n        for (TransactionEntity t : transactions) {\r\n            if (t.type != null && t.type.equals(\"INCOME\")) {\r\n                totalIncome += t.amountDouble;\r\n            } else if (t.type != null && t.type.equals(\"EXPENSE\")) {\r\n                totalExpense += t.amountDouble;\r\n            }\r\n        }\r\n        \r\n        tvIncomeValue.setText(\"+\" + formatMoney((long) totalIncome) + \" VND\");\r\n        tvExpenseValue.setText(\"-\" + formatMoney((long) totalExpense) + \" VND\");\r\n        \r\n        double total = totalIncome + totalExpense;\r\n        if (total > 0) {\r\n            int perIncome = (int) ((totalIncome * 100) / total);\r\n            int perExpense = (int) ((totalExpense * 100) / total);\r\n            progIncome.setProgress(perIncome);\r\n            progExpense.setProgress(perExpense);\r\n        } else {\r\n            progIncome.setProgress(0);\r\n            progExpense.setProgress(0);\r\n        }\r\n    }\r\n\r\n    // Format tiền VND đẹp\r\n    private String formatMoney(long amount) {\r\n        return String.format(Locale.getDefault(), \"%,d\", amount).replace(\",\", \".\");\r\n    }\r\n\r\n\r\n    // ====================== XỬ LÝ BOTTOM NAVIGATION ======================\r\n    private void setupBottomNavigation() {\r\n        bottomNavigation.setOnItemSelectedListener(item -> {\r\n            int id = item.getItemId();\r\n            Intent intent = null;\r\n\r\n            if (id == R.id.nav_home) {\r\n                // Dùng HomeActivity trong cùng package (home package)\r\n                intent = new Intent(WalletActivity.this, HomeActivity.class);\r\n            } else if (id == R.id.nav_wallet) {\r\n                return true; // Đang ở Wallet, không cần navigate\r\n            } else if (id == R.id.nav_add) {\r\n                intent = new Intent(WalletActivity.this, AddTransactionActivity.class);\r\n            } else if (id == R.id.nav_statistic) {\r\n                intent = new Intent(WalletActivity.this, StatisticActivity.class);\r\n            } else if (id == R.id.nav_settings) {\r\n                intent = new Intent(WalletActivity.this, SettingsActivity.class);\r\n            }\r\n\r\n            if (intent != null) {\r\n                startActivity(intent);\r\n                overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);\r\n            }\r\n            return true;\r\n        });\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/finmate/ui/home/WalletActivity.java b/app/src/main/java/com/finmate/ui/home/WalletActivity.java
--- a/app/src/main/java/com/finmate/ui/home/WalletActivity.java	(revision 156bc616bb4c3d046268d7f0400bef81621c2927)
+++ b/app/src/main/java/com/finmate/ui/home/WalletActivity.java	(date 1765526559314)
@@ -180,6 +180,77 @@
                     viewModel.selectTimeFilter(timeFilterStartDate, timeFilterEndDate);
                 }
 
+                @Override
+                public void on7DaysAgoSelected() {
+                    Calendar end = Calendar.getInstance();
+                    end.set(Calendar.HOUR_OF_DAY, 23);
+                    end.set(Calendar.MINUTE, 59);
+                    end.set(Calendar.SECOND, 59);
+                    end.set(Calendar.MILLISECOND, 999);
+                    timeFilterEndDate = end.getTimeInMillis();
+                    
+                    Calendar start = Calendar.getInstance();
+                    start.add(Calendar.DAY_OF_YEAR, -6);
+                    start.set(Calendar.HOUR_OF_DAY, 0);
+                    start.set(Calendar.MINUTE, 0);
+                    start.set(Calendar.SECOND, 0);
+                    start.set(Calendar.MILLISECOND, 0);
+                    timeFilterStartDate = start.getTimeInMillis();
+                    
+                    chipTimeFilter.setText(getString(R.string.time_filter_7_days));
+                    viewModel.selectTimeFilter(timeFilterStartDate, timeFilterEndDate);
+                }
+
+                @Override
+                public void on1MonthAgoSelected() {
+                    Calendar end = Calendar.getInstance();
+                    end.set(Calendar.HOUR_OF_DAY, 23);
+                    end.set(Calendar.MINUTE, 59);
+                    end.set(Calendar.SECOND, 59);
+                    end.set(Calendar.MILLISECOND, 999);
+                    timeFilterEndDate = end.getTimeInMillis();
+                    
+                    Calendar start = Calendar.getInstance();
+                    start.add(Calendar.MONTH, -1);
+                    start.set(Calendar.HOUR_OF_DAY, 0);
+                    start.set(Calendar.MINUTE, 0);
+                    start.set(Calendar.SECOND, 0);
+                    start.set(Calendar.MILLISECOND, 0);
+                    timeFilterStartDate = start.getTimeInMillis();
+                    
+                    chipTimeFilter.setText(getString(R.string.time_filter_1_month));
+                    viewModel.selectTimeFilter(timeFilterStartDate, timeFilterEndDate);
+                }
+
+                @Override
+                public void on6MonthsAgoSelected() {
+                    Calendar end = Calendar.getInstance();
+                    end.set(Calendar.HOUR_OF_DAY, 23);
+                    end.set(Calendar.MINUTE, 59);
+                    end.set(Calendar.SECOND, 59);
+                    end.set(Calendar.MILLISECOND, 999);
+                    timeFilterEndDate = end.getTimeInMillis();
+                    
+                    Calendar start = Calendar.getInstance();
+                    start.add(Calendar.MONTH, -6);
+                    start.set(Calendar.HOUR_OF_DAY, 0);
+                    start.set(Calendar.MINUTE, 0);
+                    start.set(Calendar.SECOND, 0);
+                    start.set(Calendar.MILLISECOND, 0);
+                    timeFilterStartDate = start.getTimeInMillis();
+                    
+                    chipTimeFilter.setText(getString(R.string.time_filter_6_months));
+                    viewModel.selectTimeFilter(timeFilterStartDate, timeFilterEndDate);
+                }
+
+                @Override
+                public void onAllTimeSelected() {
+                    timeFilterStartDate = null;
+                    timeFilterEndDate = null;
+                    chipTimeFilter.setText(getString(R.string.time_filter_all_time));
+                    viewModel.selectTimeFilter(null, null);
+                }
+
                 @Override
                 public void onSingleDaySelected(java.util.Date date) {
                     SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy", Locale.getDefault());
@@ -436,7 +507,10 @@
                 if (!transactionsByDate.containsKey(dateKey)) {
                     transactionsByDate.put(dateKey, new ArrayList<>());
                 }
-                transactionsByDate.get(dateKey).add(entity);
+                List<TransactionEntity> dateList = transactionsByDate.get(dateKey);
+                if (dateList != null) {
+                    dateList.add(entity);
+                }
             } catch (Exception e) {
                 // Ignore parse errors
             }
Index: app/src/main/java/com/finmate/ui/home/HomeActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.finmate.ui.home;\r\n\r\nimport android.content.Intent;\r\nimport android.content.SharedPreferences;\r\nimport android.graphics.Color;\r\nimport android.os.Bundle;\r\nimport android.view.View;\r\nimport android.widget.ImageView;\r\nimport android.widget.PopupMenu;\r\nimport android.widget.TextView;\r\nimport android.widget.Toast;\r\n\r\nimport androidx.appcompat.app.AlertDialog;\r\nimport androidx.appcompat.app.AppCompatActivity;\r\nimport androidx.lifecycle.ViewModelProvider;\r\nimport androidx.recyclerview.widget.LinearLayoutManager;\r\nimport androidx.recyclerview.widget.RecyclerView;\r\n\r\nimport android.content.Context;\r\n\r\nimport com.finmate.R;\r\nimport com.finmate.core.ui.LocaleHelper;\r\nimport com.finmate.data.local.database.entity.CategoryEntity;\r\nimport com.finmate.data.repository.CategoryRepository;\r\nimport com.finmate.ui.activities.AddTransactionActivity;\r\nimport com.finmate.ui.activities.AddWalletActivity;\r\nimport com.finmate.ui.activities.AccountActivity;\r\nimport com.finmate.ui.activities.SettingsActivity;\r\nimport com.finmate.ui.activities.StatisticActivity;\r\nimport com.finmate.ui.transaction.TransactionUIModel;\r\nimport com.finmate.ui.transaction.TransactionAdapter;\r\nimport com.finmate.ui.transaction.TransactionGroupedItem;\r\nimport com.finmate.data.local.database.entity.TransactionEntity;\r\nimport com.github.mikephil.charting.charts.LineChart;\r\nimport com.github.mikephil.charting.components.XAxis;\r\nimport com.github.mikephil.charting.components.YAxis;\r\nimport com.github.mikephil.charting.data.Entry;\r\nimport com.github.mikephil.charting.data.LineData;\r\nimport com.github.mikephil.charting.data.LineDataSet;\r\nimport com.github.mikephil.charting.formatter.ValueFormatter;\r\nimport com.google.android.material.bottomnavigation.BottomNavigationView;\r\nimport com.google.android.material.button.MaterialButton;\r\n\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.ArrayList;\r\nimport java.util.Calendar;\r\nimport java.util.List;\r\nimport java.util.Locale;\r\n\r\nimport dagger.hilt.android.AndroidEntryPoint;\r\n\r\n@AndroidEntryPoint\r\npublic class HomeActivity extends AppCompatActivity {\r\n\r\n    @Override\r\n    protected void attachBaseContext(Context newBase) {\r\n        super.attachBaseContext(LocaleHelper.applyLocale(newBase));\r\n    }\r\n\r\n    private HomeViewModel viewModel;\r\n    \r\n    // ✅ CategoryRepository để load categories và lấy icon\r\n    @javax.inject.Inject\r\n    CategoryRepository categoryRepository;\r\n    \r\n    // ✅ TransactionSyncManager để auto-sync pending transactions\r\n    @javax.inject.Inject\r\n    com.finmate.core.sync.TransactionSyncManager transactionSyncManager;\r\n\r\n    private LineChart lineChart;\r\n    private BottomNavigationView bottomNavigation;\r\n    private RecyclerView rvTransactions;\r\n    private TransactionAdapter transactionAdapter;\r\n    private ImageView btnMenuMore;\r\n    \r\n    // Filter views\r\n    private com.google.android.material.button.MaterialButton btnTimeFilter;\r\n    private TextView tvCurrentFilter, tvSyncStatus;\r\n    private ImageView imgAvatar;\r\n    private TextView tvName;\r\n    \r\n    // Summary cards\r\n    private View cardBalance, cardIncome, cardExpense;\r\n    private TextView tvBalance, tvIncome, tvExpense;\r\n    private TextView tvBalanceSubtitle, tvIncomeSubtitle, tvExpenseSubtitle;\r\n    \r\n    // Chart container\r\n    private View chartContainer;\r\n    \r\n    // ✅ Time filter state\r\n    private Long timeFilterStartDate = null;\r\n    private Long timeFilterEndDate = null;\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_home);\r\n\r\n        viewModel = new ViewModelProvider(this).get(HomeViewModel.class);\r\n\r\n        mapViews();\r\n        setupMenuMore();\r\n        setupRecyclerView();\r\n        setupBottomNavigation();\r\n        \r\n        observeViewModel();\r\n        loadCategories(); // ✅ Load categories để lấy icon\r\n        viewModel.loadHomeData(); // Load initial data\r\n        \r\n        // ✅ Bắt đầu auto-sync pending transactions\r\n        if (transactionSyncManager != null) {\r\n            transactionSyncManager.startAutoSync();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    protected void onResume() {\r\n        super.onResume();\r\n        // ✅ Reload transactions khi quay lại từ AddTransactionActivity\r\n        // Đảm bảo transaction mới được hiển thị ngay\r\n        viewModel.loadHomeData();\r\n        \r\n        // ✅ Sync pending transactions khi có mạng\r\n        if (transactionSyncManager != null) {\r\n            transactionSyncManager.syncPendingTransactions();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    protected void onPause() {\r\n        super.onPause();\r\n        // ✅ Dừng auto-sync khi activity không active\r\n        if (transactionSyncManager != null) {\r\n            transactionSyncManager.stopAutoSync();\r\n        }\r\n    }\r\n    \r\n    @Override\r\n    protected void onDestroy() {\r\n        super.onDestroy();\r\n        // ✅ Clear observers để tránh memory leak\r\n        if (viewModel != null) {\r\n            viewModel.wallets.removeObservers(this);\r\n            viewModel.transactions.removeObservers(this);\r\n        }\r\n        if (categoryRepository != null && categoriesObserver != null) {\r\n            categoryRepository.getAll().removeObserver(categoriesObserver);\r\n        }\r\n    }\r\n    \r\n    // ✅ Load categories và tạo map categoryName -> iconName\r\n    private void loadCategories() {\r\n        categoryRepository.getAll().observe(this, categories -> {\r\n            if (categories != null && !categories.isEmpty()) {\r\n                java.util.Map<String, String> categoryIconMap = new java.util.HashMap<>();\r\n                for (CategoryEntity category : categories) {\r\n                    if (category.getName() != null && category.getIcon() != null) {\r\n                        // ✅ Lưu cả tên gốc và tên đã normalize để đảm bảo match\r\n                        String categoryName = category.getName().trim();\r\n                        String iconName = category.getIcon().trim();\r\n                        if (!categoryName.isEmpty() && !iconName.isEmpty()) {\r\n                            categoryIconMap.put(categoryName, iconName);\r\n                            // ✅ Thêm cả lowercase version để match case-insensitive\r\n                            categoryIconMap.put(categoryName.toLowerCase(), iconName);\r\n                        }\r\n                    }\r\n                }\r\n                // ✅ Truyền map vào adapter và notify để refresh\r\n                if (transactionAdapter != null) {\r\n                    transactionAdapter.setCategoryIconMap(categoryIconMap);\r\n                }\r\n            } else {\r\n                // ✅ Nếu chưa có categories, sync từ backend\r\n                categoryRepository.fetchRemoteCategoriesByType(\"INCOME\");\r\n                    categoryRepository.fetchRemoteCategoriesByType(\"EXPENSE\");\r\n                }\r\n            };\r\n        categoryRepository.getAll().observe(this, categoriesObserver);\r\n    }\r\n\r\n    private void mapViews() {\r\n        lineChart = findViewById(R.id.lineChart);\r\n        bottomNavigation = findViewById(R.id.bottomNavigation);\r\n        rvTransactions = findViewById(R.id.rvTransactions);\r\n        btnMenuMore = findViewById(R.id.btnMenuMore);\r\n        chartContainer = findViewById(R.id.chartContainer);\r\n        \r\n        // Header\r\n        imgAvatar = findViewById(R.id.imgAvatar);\r\n        tvName = findViewById(R.id.tvName);\r\n        \r\n        // Filter views\r\n        btnTimeFilter = findViewById(R.id.btnTimeFilter);\r\n        tvCurrentFilter = findViewById(R.id.tvCurrentFilter);\r\n        tvSyncStatus = findViewById(R.id.tvSyncStatus);\r\n        \r\n        // Summary cards\r\n        cardBalance = findViewById(R.id.cardBalance);\r\n        cardIncome = findViewById(R.id.cardIncome);\r\n        cardExpense = findViewById(R.id.cardExpense);\r\n        tvBalance = findViewById(R.id.tvBalance);\r\n        tvIncome = findViewById(R.id.tvIncome);\r\n        tvExpense = findViewById(R.id.tvExpense);\r\n        tvBalanceSubtitle = findViewById(R.id.tvBalanceSubtitle);\r\n        tvIncomeSubtitle = findViewById(R.id.tvIncomeSubtitle);\r\n        tvExpenseSubtitle = findViewById(R.id.tvExpenseSubtitle);\r\n\r\n        bottomNavigation.setSelectedItemId(R.id.nav_home);\r\n        \r\n        setupHeader();\r\n        setupFilters();\r\n        setupCardClicks();\r\n        setupEmptyState();\r\n    }\r\n    \r\n    private void setupHeader() {\r\n        // ✅ Lấy fullName từ SharedPreferences\r\n        SharedPreferences prefs = getSharedPreferences(\"user_prefs\", MODE_PRIVATE);\r\n        String fullName = prefs.getString(\"full_name\", \"\");\r\n        if (fullName == null || fullName.isEmpty()) {\r\n            // Fallback: lấy từ user_name (backward compatibility) hoặc default\r\n            fullName = prefs.getString(\"user_name\", \"\");\r\n            if (fullName.isEmpty()) {\r\n                fullName = getString(R.string.user);\r\n            }\r\n        }\r\n        tvName.setText(fullName);\r\n        \r\n        // ✅ Avatar click → AccountActivity\r\n        imgAvatar.setOnClickListener(v -> {\r\n            startActivity(new Intent(this, AccountActivity.class));\r\n        });\r\n    }\r\n    \r\n    private void setupEmptyState() {\r\n        View emptyStateLayout = findViewById(R.id.layoutEmptyState);\r\n        if (emptyStateLayout != null) {\r\n            MaterialButton btnEmptyAdd = emptyStateLayout.findViewById(R.id.btnEmptyAdd);\r\n            if (btnEmptyAdd != null) {\r\n                btnEmptyAdd.setOnClickListener(v -> {\r\n                    startActivity(new Intent(this, AddTransactionActivity.class));\r\n                });\r\n            }\r\n        }\r\n    }\r\n    \r\n    private void setupFilters() {\r\n        // Time filter\r\n        btnTimeFilter.setOnClickListener(v -> {\r\n            com.finmate.ui.dialogs.TimeFilterBottomSheet bottomSheet = \r\n                com.finmate.ui.dialogs.TimeFilterBottomSheet.newInstance();\r\n            bottomSheet.setListener(new com.finmate.ui.dialogs.TimeFilterBottomSheet.TimeFilterListener() {\r\n                @Override\r\n                public void onTodaySelected() {\r\n                    btnTimeFilter.setText(getString(R.string.today));\r\n                    updateFilterSubtitle(getString(R.string.today));\r\n                    \r\n                    // ✅ Filter transactions for today\r\n                    Calendar cal = Calendar.getInstance();\r\n                    cal.set(Calendar.HOUR_OF_DAY, 0);\r\n                    cal.set(Calendar.MINUTE, 0);\r\n                    cal.set(Calendar.SECOND, 0);\r\n                    cal.set(Calendar.MILLISECOND, 0);\r\n                    Long startOfDay = cal.getTimeInMillis();\r\n                    \r\n                    cal.set(Calendar.HOUR_OF_DAY, 23);\r\n                    cal.set(Calendar.MINUTE, 59);\r\n                    cal.set(Calendar.SECOND, 59);\r\n                    cal.set(Calendar.MILLISECOND, 999);\r\n                    Long endOfDay = cal.getTimeInMillis();\r\n                    \r\n                    // ✅ Lưu time filter state\r\n                    timeFilterStartDate = startOfDay;\r\n                    timeFilterEndDate = endOfDay;\r\n                    \r\n                    viewModel.selectTimeFilter(startOfDay, endOfDay);\r\n                }\r\n\r\n                @Override\r\n                public void onSingleDaySelected(java.util.Date date) {\r\n                    SimpleDateFormat sdf = new SimpleDateFormat(\"dd/MM/yyyy\", Locale.getDefault());\r\n                    String dateText = sdf.format(date);\r\n                    btnTimeFilter.setText(dateText);\r\n                    updateFilterSubtitle(dateText);\r\n                    \r\n                    // ✅ Filter transactions for selected day\r\n                    Calendar cal = Calendar.getInstance();\r\n                    cal.setTime(date);\r\n                    cal.set(Calendar.HOUR_OF_DAY, 0);\r\n                    cal.set(Calendar.MINUTE, 0);\r\n                    cal.set(Calendar.SECOND, 0);\r\n                    cal.set(Calendar.MILLISECOND, 0);\r\n                    Long startOfDay = cal.getTimeInMillis();\r\n                    \r\n                    cal.set(Calendar.HOUR_OF_DAY, 23);\r\n                    cal.set(Calendar.MINUTE, 59);\r\n                    cal.set(Calendar.SECOND, 59);\r\n                    cal.set(Calendar.MILLISECOND, 999);\r\n                    Long endOfDay = cal.getTimeInMillis();\r\n                    \r\n                    // ✅ Lưu time filter state\r\n                    timeFilterStartDate = startOfDay;\r\n                    timeFilterEndDate = endOfDay;\r\n                    \r\n                    viewModel.selectTimeFilter(startOfDay, endOfDay);\r\n                }\r\n\r\n                @Override\r\n                public void onDateRangeSelected(java.util.Date startDate, java.util.Date endDate) {\r\n                    SimpleDateFormat sdf = new SimpleDateFormat(\"dd/MM/yyyy\", Locale.getDefault());\r\n                    String dateText = sdf.format(startDate) + \" - \" + sdf.format(endDate);\r\n                    btnTimeFilter.setText(dateText);\r\n                    updateFilterSubtitle(dateText);\r\n                    \r\n                    // ✅ Filter transactions for date range\r\n                    Calendar calStart = Calendar.getInstance();\r\n                    calStart.setTime(startDate);\r\n                    calStart.set(Calendar.HOUR_OF_DAY, 0);\r\n                    calStart.set(Calendar.MINUTE, 0);\r\n                    calStart.set(Calendar.SECOND, 0);\r\n                    calStart.set(Calendar.MILLISECOND, 0);\r\n                    Long startTimestamp = calStart.getTimeInMillis();\r\n                    \r\n                    Calendar calEnd = Calendar.getInstance();\r\n                    calEnd.setTime(endDate);\r\n                    calEnd.set(Calendar.HOUR_OF_DAY, 23);\r\n                    calEnd.set(Calendar.MINUTE, 59);\r\n                    calEnd.set(Calendar.SECOND, 59);\r\n                    calEnd.set(Calendar.MILLISECOND, 999);\r\n                    Long endTimestamp = calEnd.getTimeInMillis();\r\n                    \r\n                    // ✅ Lưu time filter state\r\n                    timeFilterStartDate = startTimestamp;\r\n                    timeFilterEndDate = endTimestamp;\r\n                    \r\n                    viewModel.selectTimeFilter(startTimestamp, endTimestamp);\r\n                }\r\n\r\n                @Override\r\n                public void onClear() {\r\n                    btnTimeFilter.setText(getString(R.string.today));\r\n                    updateFilterSubtitle(getString(R.string.today));\r\n                    \r\n                    // ✅ Clear filter (set to null = no filter)\r\n                    timeFilterStartDate = null;\r\n                    timeFilterEndDate = null;\r\n                    viewModel.selectTimeFilter(null, null);\r\n                }\r\n            });\r\n            bottomSheet.show(getSupportFragmentManager(), \"TimeFilterBottomSheet\");\r\n        });\r\n        \r\n        // ✅ Initialize filter subtitle\r\n        updateFilterSubtitle(getString(R.string.today));\r\n    }\r\n    \r\n    // ✅ Cập nhật filter subtitle (chỉ hiển thị time filter)\r\n    private void updateFilterSubtitle(String timeFilter) {\r\n        if (tvCurrentFilter != null) {\r\n            tvCurrentFilter.setText(timeFilter);\r\n        }\r\n    }\r\n    \r\n    private void setupCardClicks() {\r\n        // Balance card -> WalletActivity\r\n        cardBalance.setOnClickListener(v -> {\r\n            startActivity(new Intent(this, WalletActivity.class));\r\n        });\r\n        \r\n        // Income card -> IncomeStatisticActivity\r\n        cardIncome.setOnClickListener(v -> {\r\n            startActivity(new Intent(this, com.finmate.ui.activities.IncomeStatisticActivity.class));\r\n        });\r\n        \r\n        // Expense card -> StatisticActivity\r\n        cardExpense.setOnClickListener(v -> {\r\n            startActivity(new Intent(this, com.finmate.ui.activities.StatisticActivity.class));\r\n        });\r\n    }\r\n\r\n    private void observeViewModel() {\r\n        // ✅ Calculate total balance từ tất cả ví\r\n        viewModel.wallets.observe(this, wallets -> {\r\n            if (wallets != null && !wallets.isEmpty()) {\r\n                // ✅ Tất cả ví: tính tổng currentBalance\r\n                double totalBalance = 0;\r\n                for (com.finmate.data.local.database.entity.WalletEntity w : wallets) {\r\n                    totalBalance += w.currentBalance;\r\n                }\r\n                if (tvBalance != null) {\r\n                    tvBalance.setText(formatAmount(totalBalance));\r\n                }\r\n            }\r\n        });\r\n        \r\n        viewModel.transactions.observe(this, transactionEntities -> {\r\n            updateTransactionList(transactionEntities);\r\n            \r\n            // Show/hide empty state\r\n            View emptyStateLayout = findViewById(R.id.layoutEmptyState);\r\n            if (emptyStateLayout != null) {\r\n                if (transactionEntities == null || transactionEntities.isEmpty()) {\r\n                    emptyStateLayout.setVisibility(View.VISIBLE);\r\n                    rvTransactions.setVisibility(View.GONE);\r\n                } else {\r\n                    emptyStateLayout.setVisibility(View.GONE);\r\n                    rvTransactions.setVisibility(View.VISIBLE);\r\n                }\r\n            }\r\n            \r\n            // ✅ Update summary cards và chart từ transactions đã filter\r\n            updateSummaryCards(transactionEntities);\r\n            setupChart(transactionEntities);\r\n        });\r\n    }\r\n    \r\n    // ✅ Cập nhật sync status (hiển thị thời gian cập nhật cuối)\r\n    private void updateSyncStatus() {\r\n        if (tvSyncStatus != null) {\r\n            SimpleDateFormat sdf = new SimpleDateFormat(\"HH:mm\", Locale.getDefault());\r\n            String time = sdf.format(Calendar.getInstance().getTime());\r\n            tvSyncStatus.setText(getString(R.string.last_updated_at, time));\r\n        }\r\n    }\r\n    \r\n    // ✅ Tính toán và update summary cards (income, expense)\r\n    // ✅ Transactions đã được filter từ ViewModel theo wallet và time filter\r\n    private void updateSummaryCards(List<TransactionEntity> transactions) {\r\n        if (transactions == null || transactions.isEmpty()) {\r\n            if (tvIncome != null) tvIncome.setText(\"0 VND\");\r\n            if (tvExpense != null) tvExpense.setText(\"0 VND\");\r\n            String subtitle = getTimeFilterSubtitle();\r\n            if (tvIncomeSubtitle != null) tvIncomeSubtitle.setText(subtitle);\r\n            if (tvExpenseSubtitle != null) tvExpenseSubtitle.setText(subtitle);\r\n            return;\r\n        }\r\n        \r\n        double totalIncome = 0;\r\n        double totalExpense = 0;\r\n        \r\n        // ✅ Tính toán từ transactions đã được filter (theo wallet và time)\r\n        for (TransactionEntity t : transactions) {\r\n            if (t.type != null && t.type.equals(\"INCOME\")) {\r\n                totalIncome += t.amountDouble;\r\n            } else if (t.type != null && t.type.equals(\"EXPENSE\")) {\r\n                totalExpense += t.amountDouble;\r\n            }\r\n        }\r\n        \r\n        if (tvIncome != null) {\r\n            tvIncome.setText(formatAmount(totalIncome));\r\n        }\r\n        if (tvExpense != null) {\r\n            tvExpense.setText(formatAmount(totalExpense));\r\n        }\r\n        \r\n        // ✅ Update subtitle theo time filter đã chọn\r\n        String subtitle = getTimeFilterSubtitle();\r\n        if (tvIncomeSubtitle != null) {\r\n            tvIncomeSubtitle.setText(subtitle);\r\n        }\r\n        if (tvExpenseSubtitle != null) {\r\n            tvExpenseSubtitle.setText(subtitle);\r\n        }\r\n    }\r\n    \r\n    // ✅ Format subtitle dựa trên time filter đã chọn\r\n    private String getTimeFilterSubtitle() {\r\n        if (timeFilterStartDate == null && timeFilterEndDate == null) {\r\n            // Không có filter → hiển thị \"Tháng này\"\r\n            Calendar cal = Calendar.getInstance();\r\n            int nowMonth = cal.get(Calendar.MONTH) + 1;\r\n            int nowYear = cal.get(Calendar.YEAR);\r\n            return String.format(Locale.getDefault(), \"Tháng %d/%d\", nowMonth, nowYear);\r\n        }\r\n        \r\n        Calendar calStart = Calendar.getInstance();\r\n        calStart.setTimeInMillis(timeFilterStartDate);\r\n        Calendar calEnd = Calendar.getInstance();\r\n        calEnd.setTimeInMillis(timeFilterEndDate);\r\n        \r\n        SimpleDateFormat sdf = new SimpleDateFormat(\"dd/MM/yyyy\", Locale.getDefault());\r\n        \r\n        // Nếu cùng một ngày → \"Hôm nay\" hoặc \"dd/MM/yyyy\"\r\n        if (calStart.get(Calendar.YEAR) == calEnd.get(Calendar.YEAR) &&\r\n            calStart.get(Calendar.DAY_OF_YEAR) == calEnd.get(Calendar.DAY_OF_YEAR)) {\r\n            // Kiểm tra xem có phải hôm nay không\r\n            Calendar today = Calendar.getInstance();\r\n            if (calStart.get(Calendar.YEAR) == today.get(Calendar.YEAR) &&\r\n                calStart.get(Calendar.DAY_OF_YEAR) == today.get(Calendar.DAY_OF_YEAR)) {\r\n                return getString(R.string.today);\r\n            }\r\n            return sdf.format(calStart.getTime());\r\n        }\r\n        \r\n        // Nếu cùng một tháng → \"Tháng MM/yyyy\"\r\n        if (calStart.get(Calendar.YEAR) == calEnd.get(Calendar.YEAR) &&\r\n            calStart.get(Calendar.MONTH) == calEnd.get(Calendar.MONTH)) {\r\n            int month = calStart.get(Calendar.MONTH) + 1;\r\n            int year = calStart.get(Calendar.YEAR);\r\n            return String.format(Locale.getDefault(), \"Tháng %d/%d\", month, year);\r\n        }\r\n        \r\n        // Date range → \"dd/MM/yyyy - dd/MM/yyyy\"\r\n        return sdf.format(calStart.getTime()) + \" - \" + sdf.format(calEnd.getTime());\r\n    }\r\n\r\n    private void updateTransactionList(List<TransactionEntity> transactionEntities) {\r\n        if (transactionEntities == null || transactionEntities.isEmpty()) {\r\n            if (transactionAdapter != null) {\r\n                transactionAdapter.updateList(new ArrayList<>());\r\n            }\r\n            return;\r\n        }\r\n\r\n        // ✅ Group transactions theo ngày\r\n        List<TransactionGroupedItem> groupedItems = groupTransactionsByDate(transactionEntities);\r\n        if (transactionAdapter != null) {\r\n            transactionAdapter.updateList(groupedItems);\r\n        }\r\n    }\r\n    \r\n    // ✅ Group transactions theo ngày và tạo header cho mỗi ngày\r\n    private List<TransactionGroupedItem> groupTransactionsByDate(List<TransactionEntity> transactions) {\r\n        List<TransactionGroupedItem> groupedItems = new ArrayList<>();\r\n        \r\n        // Parse và group transactions theo ngày\r\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\", Locale.getDefault());\r\n        SimpleDateFormat isoFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\", Locale.getDefault());\r\n        SimpleDateFormat displayDateFormat = new SimpleDateFormat(\"dd/MM/yyyy\", Locale.getDefault());\r\n        // Sử dụng locale tiếng Việt để format thứ\r\n        SimpleDateFormat dayOfWeekFormat = new SimpleDateFormat(\"EEEE\", new Locale(\"vi\", \"VN\"));\r\n        \r\n        // Map để lưu transactions theo ngày\r\n        java.util.Map<String, List<TransactionEntity>> transactionsByDate = new java.util.LinkedHashMap<>();\r\n        \r\n        for (TransactionEntity entity : transactions) {\r\n            if (entity.date == null || entity.date.isEmpty()) continue;\r\n            \r\n            try {\r\n                java.util.Date date;\r\n                // Try parsing as ISO format first\r\n                try {\r\n                    date = isoFormat.parse(entity.date);\r\n                } catch (Exception e) {\r\n                    // Fallback to simple date format\r\n                    date = dateFormat.parse(entity.date);\r\n                }\r\n                \r\n                String dateKey = dateFormat.format(date);\r\n                \r\n                if (!transactionsByDate.containsKey(dateKey)) {\r\n                    transactionsByDate.put(dateKey, new ArrayList<>());\r\n                }\r\n                transactionsByDate.get(dateKey).add(entity);\r\n            } catch (Exception e) {\r\n                // Ignore parse errors\r\n            }\r\n        }\r\n        \r\n        // Tạo grouped items với header cho mỗi ngày\r\n        for (java.util.Map.Entry<String, List<TransactionEntity>> entry : transactionsByDate.entrySet()) {\r\n            String dateKey = entry.getKey();\r\n            List<TransactionEntity> dayTransactions = entry.getValue();\r\n            \r\n            try {\r\n                java.util.Date date = dateFormat.parse(dateKey);\r\n                \r\n                // Format ngày: \"dd/MM/yyyy\"\r\n                String dateHeader = displayDateFormat.format(date);\r\n                \r\n                // Format thứ: \"Thứ 2\", \"Thứ 3\", ...\r\n                String dayOfWeek = formatDayOfWeek(dayOfWeekFormat.format(date));\r\n                \r\n                // Thêm header\r\n                groupedItems.add(new TransactionGroupedItem(dateHeader, dayOfWeek));\r\n                \r\n                // Thêm transactions của ngày đó\r\n                for (TransactionEntity entity : dayTransactions) {\r\n                    TransactionUIModel uiModel = new TransactionUIModel(\r\n                            entity.name,\r\n                            entity.category,\r\n                            entity.amount,\r\n                            entity.wallet,\r\n                            entity.date,\r\n                            entity.type // ✅ Truyền type để adapter có thể format màu và dấu\r\n                    );\r\n                    groupedItems.add(new TransactionGroupedItem(uiModel));\r\n                }\r\n            } catch (Exception e) {\r\n                // Ignore parse errors\r\n            }\r\n        }\r\n        \r\n        return groupedItems;\r\n    }\r\n    \r\n    // ✅ Format day of week: \"Monday\" -> \"Thứ 2\", \"Tuesday\" -> \"Thứ 3\", ...\r\n    private String formatDayOfWeek(String dayOfWeek) {\r\n        // Convert to Vietnamese day of week\r\n        java.util.Map<String, String> dayMap = new java.util.HashMap<>();\r\n        dayMap.put(\"Monday\", \"Thứ 2\");\r\n        dayMap.put(\"Tuesday\", \"Thứ 3\");\r\n        dayMap.put(\"Wednesday\", \"Thứ 4\");\r\n        dayMap.put(\"Thursday\", \"Thứ 5\");\r\n        dayMap.put(\"Friday\", \"Thứ 6\");\r\n        dayMap.put(\"Saturday\", \"Thứ 7\");\r\n        dayMap.put(\"Sunday\", \"Chủ nhật\");\r\n        \r\n        // Vietnamese locale (full name)\r\n        dayMap.put(\"Thứ Hai\", \"Thứ 2\");\r\n        dayMap.put(\"Thứ Ba\", \"Thứ 3\");\r\n        dayMap.put(\"Thứ Tư\", \"Thứ 4\");\r\n        dayMap.put(\"Thứ Năm\", \"Thứ 5\");\r\n        dayMap.put(\"Thứ Sáu\", \"Thứ 6\");\r\n        dayMap.put(\"Thứ Bảy\", \"Thứ 7\");\r\n        dayMap.put(\"Chủ Nhật\", \"Chủ nhật\");\r\n        \r\n        // Check if already formatted\r\n        if (dayMap.containsKey(dayOfWeek)) {\r\n            return dayMap.get(dayOfWeek);\r\n        }\r\n        \r\n        // Try to match partial (case insensitive)\r\n        String lowerDay = dayOfWeek.toLowerCase();\r\n        for (java.util.Map.Entry<String, String> entry : dayMap.entrySet()) {\r\n            if (entry.getKey().toLowerCase().contains(lowerDay) || lowerDay.contains(entry.getKey().toLowerCase())) {\r\n                return entry.getValue();\r\n            }\r\n        }\r\n        \r\n        return dayOfWeek; // Return original if no match\r\n    }\r\n\r\n    private void setupMenuMore() {\r\n        btnMenuMore.setOnClickListener(v -> {\r\n            PopupMenu popup = new PopupMenu(HomeActivity.this, btnMenuMore);\r\n            popup.getMenuInflater().inflate(R.menu.menu_wallet_options, popup.getMenu());\r\n\r\n            popup.setOnMenuItemClickListener(item -> {\r\n                int id = item.getItemId();\r\n                // ✅ Bỏ \"Chọn ví\" khỏi menu, chỉ giữ \"Thêm ví\"\r\n                if (id == R.id.action_add_wallet) {\r\n                    startActivity(new Intent(HomeActivity.this, AddWalletActivity.class));\r\n                    return true;\r\n                }\r\n                return false;\r\n            });\r\n            popup.show();\r\n        });\r\n    }\r\n\r\n\r\n    private void setupRecyclerView() {\r\n        rvTransactions.setLayoutManager(new LinearLayoutManager(this));\r\n        transactionAdapter = new TransactionAdapter(new ArrayList<>()); \r\n        rvTransactions.setAdapter(transactionAdapter);\r\n        \r\n        // ✅ Disable nested scrolling của RecyclerView vì đã có NestedScrollView bên ngoài\r\n        // NestedScrollView sẽ handle scroll, RecyclerView chỉ hiển thị content\r\n        rvTransactions.setNestedScrollingEnabled(false);\r\n        rvTransactions.setHasFixedSize(false);\r\n    }\r\n\r\n    private void setupChart(List<TransactionEntity> transactions) {\r\n        if (transactions == null || transactions.isEmpty()) {\r\n            // ✅ Ẩn chart nếu không có data\r\n            if (chartContainer != null) {\r\n                chartContainer.setVisibility(View.GONE);\r\n            }\r\n            return;\r\n        }\r\n        \r\n        // ✅ Hiển thị chart\r\n        if (chartContainer != null) {\r\n            chartContainer.setVisibility(View.VISIBLE);\r\n        }\r\n        \r\n        // ✅ Tính toán income và expense từ transactions (6 tháng gần nhất)\r\n        Calendar now = Calendar.getInstance();\r\n        String[] months = new String[6];\r\n        double[] monthlyIncome = new double[6];\r\n        double[] monthlyExpense = new double[6];\r\n        \r\n        // ✅ Tạo labels cho 6 tháng gần nhất (bao gồm tháng hiện tại)\r\n        Calendar cal = Calendar.getInstance();\r\n        for (int i = 5; i >= 0; i--) {\r\n            months[i] = String.format(Locale.getDefault(), \"T%d\", cal.get(Calendar.MONTH) + 1);\r\n            cal.add(Calendar.MONTH, -1);\r\n        }\r\n        \r\n        // ✅ Group transactions by month thực tế\r\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\", Locale.getDefault());\r\n        // Try ISO format first, then other formats\r\n        SimpleDateFormat isoFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\", Locale.getDefault());\r\n        \r\n        for (TransactionEntity t : transactions) {\r\n            if (t.date == null || t.date.isEmpty()) continue;\r\n            \r\n            try {\r\n                java.util.Date date;\r\n                // Try parsing as ISO format first\r\n                try {\r\n                    date = isoFormat.parse(t.date);\r\n                } catch (Exception e) {\r\n                    // Fallback to simple date format\r\n                    date = dateFormat.parse(t.date);\r\n                }\r\n                \r\n                Calendar transactionCal = Calendar.getInstance();\r\n                transactionCal.setTime(date);\r\n                \r\n                // Calculate difference in months\r\n                int diffMonths = (now.get(Calendar.YEAR) - transactionCal.get(Calendar.YEAR)) * 12\r\n                        + (now.get(Calendar.MONTH) - transactionCal.get(Calendar.MONTH));\r\n                \r\n                // Only include transactions from last 6 months (0 to 5)\r\n                if (diffMonths >= 0 && diffMonths < 6) {\r\n                    int index = 5 - diffMonths; // 0 = 6 tháng trước, 5 = tháng này\r\n                    if (\"INCOME\".equals(t.type)) {\r\n                        monthlyIncome[index] += t.amountDouble;\r\n                    } else if (\"EXPENSE\".equals(t.type)) {\r\n                        monthlyExpense[index] += t.amountDouble;\r\n                    }\r\n                }\r\n            } catch (Exception e) {\r\n                // Ignore parse errors\r\n            }\r\n        }\r\n        \r\n        // ✅ Tạo chart data\r\n        ArrayList<Entry> income = new ArrayList<>();\r\n        ArrayList<Entry> expense = new ArrayList<>();\r\n\r\n        for (int i = 0; i < 6; i++) {\r\n            income.add(new Entry(i + 1, (float) monthlyIncome[i]));\r\n            expense.add(new Entry(i + 1, (float) monthlyExpense[i]));\r\n        }\r\n\r\n        LineDataSet incomeSet = new LineDataSet(income, getString(R.string.income_label));\r\n        incomeSet.setColor(Color.GREEN);\r\n        incomeSet.setLineWidth(2f);\r\n        incomeSet.setCircleColor(Color.GREEN);\r\n        incomeSet.setCircleRadius(5f);\r\n        incomeSet.setDrawValues(false);\r\n\r\n        LineDataSet expenseSet = new LineDataSet(expense, getString(R.string.expense_label));\r\n        expenseSet.setColor(Color.RED);\r\n        expenseSet.setLineWidth(2f);\r\n        expenseSet.setCircleColor(Color.RED);\r\n        expenseSet.setCircleRadius(5f);\r\n        expenseSet.setDrawValues(false);\r\n\r\n        LineData data = new LineData(incomeSet, expenseSet);\r\n        lineChart.setData(data);\r\n        \r\n        // ✅ Cải thiện UI chart\r\n        lineChart.setDrawGridBackground(false);\r\n        lineChart.getDescription().setEnabled(false);\r\n        lineChart.getLegend().setEnabled(true);\r\n        lineChart.getAxisRight().setEnabled(false);\r\n        \r\n        // ✅ X-axis với labels tháng\r\n        XAxis xAxis = lineChart.getXAxis();\r\n        xAxis.setPosition(XAxis.XAxisPosition.BOTTOM);\r\n        xAxis.setGranularity(1f);\r\n        xAxis.setDrawGridLines(false);\r\n        xAxis.setValueFormatter(new ValueFormatter() {\r\n            @Override\r\n            public String getFormattedValue(float value) {\r\n                int index = (int) value - 1;\r\n                return (index >= 0 && index < months.length) ? months[index] : \"\";\r\n            }\r\n        });\r\n        \r\n        // ✅ Y-axis\r\n        YAxis leftAxis = lineChart.getAxisLeft();\r\n        leftAxis.setTextColor(Color.parseColor(\"#FFFFFF\"));\r\n        leftAxis.setGridColor(Color.parseColor(\"#33FFFFFF\"));\r\n        \r\n        lineChart.invalidate(); // Refresh chart\r\n    }\r\n\r\n    private void setupBottomNavigation() {\r\n        bottomNavigation.setOnItemSelectedListener(item -> {\r\n            int id = item.getItemId();\r\n            Intent intent = null;\r\n\r\n            if (id == R.id.nav_home) {\r\n                return true; // Đang ở Home, không cần navigate\r\n            } else if (id == R.id.nav_wallet) {\r\n                intent = new Intent(this, WalletActivity.class);\r\n            } else if (id == R.id.nav_add) {\r\n                intent = new Intent(this, AddTransactionActivity.class);\r\n            } else if (id == R.id.nav_statistic) {\r\n                intent = new Intent(this, StatisticActivity.class);\r\n            } else if (id == R.id.nav_settings) {\r\n                intent = new Intent(this, SettingsActivity.class);\r\n            }\r\n\r\n            if (intent != null) {\r\n                startActivity(intent);\r\n                overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);\r\n            }\r\n            return true;\r\n        });\r\n    }\r\n    \r\n    // ✅ Format số tiền ngắn gọn để không làm vỡ layout\r\n    private String formatAmount(double amount) {\r\n        if (amount >= 1_000_000_000) {\r\n            // >= 1 tỷ: hiển thị dạng 1.2B\r\n            return String.format(Locale.getDefault(), \"%.1fB VND\", amount / 1_000_000_000);\r\n        } else if (amount >= 1_000_000) {\r\n            // >= 1 triệu: hiển thị dạng 1.2M\r\n            return String.format(Locale.getDefault(), \"%.1fM VND\", amount / 1_000_000);\r\n        } else if (amount >= 1_000) {\r\n            // >= 1 nghìn: hiển thị dạng 1.2K\r\n            return String.format(Locale.getDefault(), \"%.1fK VND\", amount / 1_000);\r\n        } else {\r\n            // < 1 nghìn: hiển thị đầy đủ\r\n            return String.format(Locale.getDefault(), \"%,.0f VND\", amount);\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/finmate/ui/home/HomeActivity.java b/app/src/main/java/com/finmate/ui/home/HomeActivity.java
--- a/app/src/main/java/com/finmate/ui/home/HomeActivity.java	(revision 156bc616bb4c3d046268d7f0400bef81621c2927)
+++ b/app/src/main/java/com/finmate/ui/home/HomeActivity.java	(date 1765527707114)
@@ -41,11 +41,17 @@
 import com.google.android.material.bottomnavigation.BottomNavigationView;
 import com.google.android.material.button.MaterialButton;
 
+import com.finmate.ui.statistics.StatisticsUtils;
+
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Calendar;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Locale;
+import java.util.Map;
 
 import dagger.hilt.android.AndroidEntryPoint;
 
@@ -63,9 +69,13 @@
     @javax.inject.Inject
     CategoryRepository categoryRepository;
     
+    // ✅ Observer cho categories
+    private androidx.lifecycle.Observer<List<CategoryEntity>> categoriesObserver;
+    
     // ✅ TransactionSyncManager để auto-sync pending transactions
-    @javax.inject.Inject
-    com.finmate.core.sync.TransactionSyncManager transactionSyncManager;
+    // Note: TransactionSyncManager có thể chưa được tạo, comment lại để tránh lỗi compile
+    // @javax.inject.Inject
+    // com.finmate.core.sync.TransactionSyncManager transactionSyncManager;
 
     private LineChart lineChart;
     private BottomNavigationView bottomNavigation;
@@ -90,6 +100,7 @@
     // ✅ Time filter state
     private Long timeFilterStartDate = null;
     private Long timeFilterEndDate = null;
+    private String currentFilterType = "1_month"; // "today", "7_days", "1_month", "6_months", "all_time"
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -103,16 +114,15 @@
         setupRecyclerView();
         setupBottomNavigation();
         
+        // ✅ Set default date filter to "1 month ago" TRƯỚC KHI observe và load data
+        setDefaultThisMonthRange();
+        
         observeViewModel();
         loadCategories(); // ✅ Load categories để lấy icon
+        
         viewModel.loadHomeData(); // Load initial data
-        
-        // ✅ Bắt đầu auto-sync pending transactions
-        if (transactionSyncManager != null) {
-            transactionSyncManager.startAutoSync();
-        }
     }
-
+    
     @Override
     protected void onResume() {
         super.onResume();
@@ -121,18 +131,18 @@
         viewModel.loadHomeData();
         
         // ✅ Sync pending transactions khi có mạng
-        if (transactionSyncManager != null) {
-            transactionSyncManager.syncPendingTransactions();
-        }
+        // if (transactionSyncManager != null) {
+        //     transactionSyncManager.syncPendingTransactions();
+        // }
     }
 
     @Override
     protected void onPause() {
         super.onPause();
         // ✅ Dừng auto-sync khi activity không active
-        if (transactionSyncManager != null) {
-            transactionSyncManager.stopAutoSync();
-        }
+        // if (transactionSyncManager != null) {
+        //     transactionSyncManager.stopAutoSync();
+        // }
     }
     
     @Override
@@ -150,7 +160,7 @@
     
     // ✅ Load categories và tạo map categoryName -> iconName
     private void loadCategories() {
-        categoryRepository.getAll().observe(this, categories -> {
+        categoriesObserver = categories -> {
             if (categories != null && !categories.isEmpty()) {
                 java.util.Map<String, String> categoryIconMap = new java.util.HashMap<>();
                 for (CategoryEntity category : categories) {
@@ -166,15 +176,22 @@
                     }
                 }
                 // ✅ Truyền map vào adapter và notify để refresh
-                if (transactionAdapter != null) {
-                    transactionAdapter.setCategoryIconMap(categoryIconMap);
+                if (transactionAdapter != null && transactionAdapter instanceof com.finmate.ui.transaction.TransactionAdapter) {
+                    // Note: TransactionAdapter có thể cần method setCategoryIconMap
+                    // Nếu chưa có, sẽ bỏ qua
+                    try {
+                        java.lang.reflect.Method method = transactionAdapter.getClass().getMethod("setCategoryIconMap", java.util.Map.class);
+                        method.invoke(transactionAdapter, categoryIconMap);
+                    } catch (Exception e) {
+                        // Method không tồn tại, bỏ qua
+                    }
                 }
             } else {
                 // ✅ Nếu chưa có categories, sync từ backend
                 categoryRepository.fetchRemoteCategoriesByType("INCOME");
-                    categoryRepository.fetchRemoteCategoriesByType("EXPENSE");
-                }
-            };
+                categoryRepository.fetchRemoteCategoriesByType("EXPENSE");
+            }
+        };
         categoryRepository.getAll().observe(this, categoriesObserver);
     }
 
@@ -205,7 +222,9 @@
         tvIncomeSubtitle = findViewById(R.id.tvIncomeSubtitle);
         tvExpenseSubtitle = findViewById(R.id.tvExpenseSubtitle);
 
-        bottomNavigation.setSelectedItemId(R.id.nav_home);
+        if (bottomNavigation != null) {
+            bottomNavigation.setSelectedItemId(R.id.nav_home);
+        }
         
         setupHeader();
         setupFilters();
@@ -224,12 +243,16 @@
                 fullName = getString(R.string.user);
             }
         }
-        tvName.setText(fullName);
+        if (tvName != null) {
+            tvName.setText(fullName);
+        }
         
         // ✅ Avatar click → AccountActivity
-        imgAvatar.setOnClickListener(v -> {
-            startActivity(new Intent(this, AccountActivity.class));
-        });
+        if (imgAvatar != null) {
+            imgAvatar.setOnClickListener(v -> {
+                startActivity(new Intent(this, AccountActivity.class));
+            });
+        }
     }
     
     private void setupEmptyState() {
@@ -246,14 +269,16 @@
     
     private void setupFilters() {
         // Time filter
+        if (btnTimeFilter == null) return;
         btnTimeFilter.setOnClickListener(v -> {
             com.finmate.ui.dialogs.TimeFilterBottomSheet bottomSheet = 
                 com.finmate.ui.dialogs.TimeFilterBottomSheet.newInstance();
             bottomSheet.setListener(new com.finmate.ui.dialogs.TimeFilterBottomSheet.TimeFilterListener() {
                 @Override
                 public void onTodaySelected() {
-                    btnTimeFilter.setText(getString(R.string.today));
-                    updateFilterSubtitle(getString(R.string.today));
+                    currentFilterType = "today";
+                    btnTimeFilter.setText(getString(R.string.time_filter_today));
+                    updateFilterSubtitle(getString(R.string.time_filter_today));
                     
                     // ✅ Filter transactions for today
                     Calendar cal = Calendar.getInstance();
@@ -276,6 +301,85 @@
                     viewModel.selectTimeFilter(startOfDay, endOfDay);
                 }
 
+                @Override
+                public void on7DaysAgoSelected() {
+                    currentFilterType = "7_days";
+                    Calendar end = Calendar.getInstance();
+                    end.set(Calendar.HOUR_OF_DAY, 23);
+                    end.set(Calendar.MINUTE, 59);
+                    end.set(Calendar.SECOND, 59);
+                    end.set(Calendar.MILLISECOND, 999);
+                    timeFilterEndDate = end.getTimeInMillis();
+                    
+                    Calendar start = Calendar.getInstance();
+                    start.add(Calendar.DAY_OF_YEAR, -6);
+                    start.set(Calendar.HOUR_OF_DAY, 0);
+                    start.set(Calendar.MINUTE, 0);
+                    start.set(Calendar.SECOND, 0);
+                    start.set(Calendar.MILLISECOND, 0);
+                    timeFilterStartDate = start.getTimeInMillis();
+                    
+                    btnTimeFilter.setText(getString(R.string.time_filter_7_days));
+                    updateFilterSubtitle(getString(R.string.time_filter_7_days));
+                    viewModel.selectTimeFilter(timeFilterStartDate, timeFilterEndDate);
+                }
+
+                @Override
+                public void on1MonthAgoSelected() {
+                    currentFilterType = "1_month";
+                    Calendar end = Calendar.getInstance();
+                    end.set(Calendar.HOUR_OF_DAY, 23);
+                    end.set(Calendar.MINUTE, 59);
+                    end.set(Calendar.SECOND, 59);
+                    end.set(Calendar.MILLISECOND, 999);
+                    timeFilterEndDate = end.getTimeInMillis();
+                    
+                    Calendar start = Calendar.getInstance();
+                    start.add(Calendar.MONTH, -1);
+                    start.set(Calendar.HOUR_OF_DAY, 0);
+                    start.set(Calendar.MINUTE, 0);
+                    start.set(Calendar.SECOND, 0);
+                    start.set(Calendar.MILLISECOND, 0);
+                    timeFilterStartDate = start.getTimeInMillis();
+                    
+                    btnTimeFilter.setText(getString(R.string.time_filter_1_month));
+                    updateFilterSubtitle(getString(R.string.time_filter_1_month));
+                    viewModel.selectTimeFilter(timeFilterStartDate, timeFilterEndDate);
+                }
+
+                @Override
+                public void on6MonthsAgoSelected() {
+                    currentFilterType = "6_months";
+                    Calendar end = Calendar.getInstance();
+                    end.set(Calendar.HOUR_OF_DAY, 23);
+                    end.set(Calendar.MINUTE, 59);
+                    end.set(Calendar.SECOND, 59);
+                    end.set(Calendar.MILLISECOND, 999);
+                    timeFilterEndDate = end.getTimeInMillis();
+                    
+                    Calendar start = Calendar.getInstance();
+                    start.add(Calendar.MONTH, -6);
+                    start.set(Calendar.HOUR_OF_DAY, 0);
+                    start.set(Calendar.MINUTE, 0);
+                    start.set(Calendar.SECOND, 0);
+                    start.set(Calendar.MILLISECOND, 0);
+                    timeFilterStartDate = start.getTimeInMillis();
+                    
+                    btnTimeFilter.setText(getString(R.string.time_filter_6_months));
+                    updateFilterSubtitle(getString(R.string.time_filter_6_months));
+                    viewModel.selectTimeFilter(timeFilterStartDate, timeFilterEndDate);
+                }
+
+                @Override
+                public void onAllTimeSelected() {
+                    currentFilterType = "all_time";
+                    timeFilterStartDate = null;
+                    timeFilterEndDate = null;
+                    btnTimeFilter.setText(getString(R.string.time_filter_all_time));
+                    updateFilterSubtitle(getString(R.string.time_filter_all_time));
+                    viewModel.selectTimeFilter(null, null);
+                }
+
                 @Override
                 public void onSingleDaySelected(java.util.Date date) {
                     SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy", Locale.getDefault());
@@ -307,6 +411,7 @@
 
                 @Override
                 public void onDateRangeSelected(java.util.Date startDate, java.util.Date endDate) {
+                    currentFilterType = "date_range";
                     SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy", Locale.getDefault());
                     String dateText = sdf.format(startDate) + " - " + sdf.format(endDate);
                     btnTimeFilter.setText(dateText);
@@ -351,7 +456,34 @@
         });
         
         // ✅ Initialize filter subtitle
-        updateFilterSubtitle(getString(R.string.today));
+        // Will be set by setDefaultThisMonthRange()
+    }
+    
+    /**
+     * ✅ Set default date range to 1 month ago
+     */
+    private void setDefaultThisMonthRange() {
+        Calendar end = Calendar.getInstance();
+        end.set(Calendar.HOUR_OF_DAY, 23);
+        end.set(Calendar.MINUTE, 59);
+        end.set(Calendar.SECOND, 59);
+        end.set(Calendar.MILLISECOND, 999);
+        timeFilterEndDate = end.getTimeInMillis();
+        
+        Calendar start = Calendar.getInstance();
+        start.add(Calendar.MONTH, -1);
+        start.set(Calendar.HOUR_OF_DAY, 0);
+        start.set(Calendar.MINUTE, 0);
+        start.set(Calendar.SECOND, 0);
+        start.set(Calendar.MILLISECOND, 0);
+        timeFilterStartDate = start.getTimeInMillis();
+        
+        currentFilterType = "1_month";
+        // Set button text and subtitle
+        if (btnTimeFilter != null) {
+            btnTimeFilter.setText(getString(R.string.time_filter_1_month));
+        }
+        updateFilterSubtitle(getString(R.string.time_filter_1_month));
     }
     
     // ✅ Cập nhật filter subtitle (chỉ hiển thị time filter)
@@ -363,19 +495,25 @@
     
     private void setupCardClicks() {
         // Balance card -> WalletActivity
-        cardBalance.setOnClickListener(v -> {
-            startActivity(new Intent(this, WalletActivity.class));
-        });
+        if (cardBalance != null) {
+            cardBalance.setOnClickListener(v -> {
+                startActivity(new Intent(this, WalletActivity.class));
+            });
+        }
         
         // Income card -> IncomeStatisticActivity
-        cardIncome.setOnClickListener(v -> {
-            startActivity(new Intent(this, com.finmate.ui.activities.IncomeStatisticActivity.class));
-        });
+        if (cardIncome != null) {
+            cardIncome.setOnClickListener(v -> {
+                startActivity(new Intent(this, com.finmate.ui.activities.IncomeStatisticActivity.class));
+            });
+        }
         
         // Expense card -> StatisticActivity
-        cardExpense.setOnClickListener(v -> {
-            startActivity(new Intent(this, com.finmate.ui.activities.StatisticActivity.class));
-        });
+        if (cardExpense != null) {
+            cardExpense.setOnClickListener(v -> {
+                startActivity(new Intent(this, com.finmate.ui.activities.StatisticActivity.class));
+            });
+        }
     }
 
     private void observeViewModel() {
@@ -390,15 +528,29 @@
                 if (tvBalance != null) {
                     tvBalance.setText(formatAmount(totalBalance));
                 }
+                
+                // ✅ Sau khi wallets được load, load transactions với filter đúng
+                // Đảm bảo transactions được load với filter đúng ngay từ đầu
+                // Set wallet selection trước (null = all wallets)
+                viewModel.selectWallet(null, null);
+                
+                // Sau đó apply time filter (nếu có)
+                if (timeFilterStartDate != null && timeFilterEndDate != null) {
+                    android.util.Log.d("HomeActivity", "Applying time filter: " + timeFilterStartDate + " to " + timeFilterEndDate);
+                    viewModel.selectTimeFilter(timeFilterStartDate, timeFilterEndDate);
+                } else {
+                    android.util.Log.d("HomeActivity", "No time filter, transactions already loaded by selectWallet()");
+                }
             }
         });
         
         viewModel.transactions.observe(this, transactionEntities -> {
+            android.util.Log.d("HomeActivity", "Transactions updated: " + (transactionEntities != null ? transactionEntities.size() : 0) + " items");
             updateTransactionList(transactionEntities);
             
             // Show/hide empty state
             View emptyStateLayout = findViewById(R.id.layoutEmptyState);
-            if (emptyStateLayout != null) {
+            if (emptyStateLayout != null && rvTransactions != null) {
                 if (transactionEntities == null || transactionEntities.isEmpty()) {
                     emptyStateLayout.setVisibility(View.VISIBLE);
                     rvTransactions.setVisibility(View.GONE);
@@ -456,22 +608,25 @@
         
         // ✅ Update subtitle theo time filter đã chọn
         String subtitle = getTimeFilterSubtitle();
-        if (tvIncomeSubtitle != null) {
-            tvIncomeSubtitle.setText(subtitle);
-        }
-        if (tvExpenseSubtitle != null) {
-            tvExpenseSubtitle.setText(subtitle);
+        if (subtitle != null) {
+            if (tvIncomeSubtitle != null) {
+                tvIncomeSubtitle.setText(subtitle);
+            }
+            if (tvExpenseSubtitle != null) {
+                tvExpenseSubtitle.setText(subtitle);
+            }
         }
     }
     
     // ✅ Format subtitle dựa trên time filter đã chọn
     private String getTimeFilterSubtitle() {
         if (timeFilterStartDate == null && timeFilterEndDate == null) {
-            // Không có filter → hiển thị "Tháng này"
-            Calendar cal = Calendar.getInstance();
-            int nowMonth = cal.get(Calendar.MONTH) + 1;
-            int nowYear = cal.get(Calendar.YEAR);
-            return String.format(Locale.getDefault(), "Tháng %d/%d", nowMonth, nowYear);
+            // Không có filter → hiển thị "Tất cả"
+            return "Tất cả";
+        }
+        
+        if (timeFilterStartDate == null || timeFilterEndDate == null) {
+            return "Tất cả";
         }
         
         Calendar calStart = Calendar.getInstance();
@@ -552,7 +707,10 @@
                 if (!transactionsByDate.containsKey(dateKey)) {
                     transactionsByDate.put(dateKey, new ArrayList<>());
                 }
-                transactionsByDate.get(dateKey).add(entity);
+                List<TransactionEntity> dateList = transactionsByDate.get(dateKey);
+                if (dateList != null) {
+                    dateList.add(entity);
+                }
             } catch (Exception e) {
                 // Ignore parse errors
             }
@@ -652,6 +810,7 @@
 
 
     private void setupRecyclerView() {
+        if (rvTransactions == null) return;
         rvTransactions.setLayoutManager(new LinearLayoutManager(this));
         transactionAdapter = new TransactionAdapter(new ArrayList<>()); 
         rvTransactions.setAdapter(transactionAdapter);
@@ -663,8 +822,11 @@
     }
 
     private void setupChart(List<TransactionEntity> transactions) {
+        android.util.Log.d("HomeActivity", "setupChart called with " + (transactions != null ? transactions.size() : 0) + " transactions, filterType: " + currentFilterType);
+        
         if (transactions == null || transactions.isEmpty()) {
             // ✅ Ẩn chart nếu không có data
+            android.util.Log.d("HomeActivity", "No transactions, hiding chart");
             if (chartContainer != null) {
                 chartContainer.setVisibility(View.GONE);
             }
@@ -676,75 +838,162 @@
             chartContainer.setVisibility(View.VISIBLE);
         }
         
-        // ✅ Tính toán income và expense từ transactions (6 tháng gần nhất)
-        Calendar now = Calendar.getInstance();
-        String[] months = new String[6];
-        double[] monthlyIncome = new double[6];
-        double[] monthlyExpense = new double[6];
-        
-        // ✅ Tạo labels cho 6 tháng gần nhất (bao gồm tháng hiện tại)
-        Calendar cal = Calendar.getInstance();
-        for (int i = 5; i >= 0; i--) {
-            months[i] = String.format(Locale.getDefault(), "T%d", cal.get(Calendar.MONTH) + 1);
-            cal.add(Calendar.MONTH, -1);
-        }
+        // ✅ Format chart theo filter type
+        List<Entry> incomeEntries = new ArrayList<>();
+        List<Entry> expenseEntries = new ArrayList<>();
+        List<String> labels = new ArrayList<>();
         
-        // ✅ Group transactions by month thực tế
-        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd", Locale.getDefault());
-        // Try ISO format first, then other formats
-        SimpleDateFormat isoFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.getDefault());
-        
+        // Separate income and expense transactions và đảm bảo amountDouble được set
+        List<TransactionEntity> incomeTransactions = new ArrayList<>();
+        List<TransactionEntity> expenseTransactions = new ArrayList<>();
         for (TransactionEntity t : transactions) {
-            if (t.date == null || t.date.isEmpty()) continue;
-            
-            try {
-                java.util.Date date;
-                // Try parsing as ISO format first
+            // ✅ Parse amount string thành amountDouble nếu amountDouble = 0
+            if (t.amountDouble == 0.0 && t.amount != null && !t.amount.isEmpty()) {
                 try {
-                    date = isoFormat.parse(t.date);
+                    // Remove all non-numeric characters except decimal point
+                    String cleanAmount = t.amount.replaceAll("[^0-9.]", "");
+                    if (!cleanAmount.isEmpty()) {
+                        t.amountDouble = Double.parseDouble(cleanAmount);
+                    }
                 } catch (Exception e) {
-                    // Fallback to simple date format
-                    date = dateFormat.parse(t.date);
+                    android.util.Log.e("HomeActivity", "Error parsing amount: " + t.amount, e);
                 }
-                
-                Calendar transactionCal = Calendar.getInstance();
-                transactionCal.setTime(date);
-                
-                // Calculate difference in months
-                int diffMonths = (now.get(Calendar.YEAR) - transactionCal.get(Calendar.YEAR)) * 12
-                        + (now.get(Calendar.MONTH) - transactionCal.get(Calendar.MONTH));
-                
-                // Only include transactions from last 6 months (0 to 5)
-                if (diffMonths >= 0 && diffMonths < 6) {
-                    int index = 5 - diffMonths; // 0 = 6 tháng trước, 5 = tháng này
-                    if ("INCOME".equals(t.type)) {
-                        monthlyIncome[index] += t.amountDouble;
-                    } else if ("EXPENSE".equals(t.type)) {
-                        monthlyExpense[index] += t.amountDouble;
-                    }
-                }
-            } catch (Exception e) {
-                // Ignore parse errors
-            }
-        }
-        
-        // ✅ Tạo chart data
-        ArrayList<Entry> income = new ArrayList<>();
-        ArrayList<Entry> expense = new ArrayList<>();
-
-        for (int i = 0; i < 6; i++) {
-            income.add(new Entry(i + 1, (float) monthlyIncome[i]));
-            expense.add(new Entry(i + 1, (float) monthlyExpense[i]));
-        }
-
-        LineDataSet incomeSet = new LineDataSet(income, getString(R.string.income_label));
+            }
+            
+            if ("INCOME".equals(t.type)) {
+                incomeTransactions.add(t);
+            } else if ("EXPENSE".equals(t.type) || (t.type == null || t.type.isEmpty())) {
+                // Default to EXPENSE if type is null/empty for backward compatibility
+                expenseTransactions.add(t);
+            }
+        }
+        
+        android.util.Log.d("HomeActivity", "Income transactions: " + incomeTransactions.size() + ", Expense transactions: " + expenseTransactions.size());
+        
+        switch (currentFilterType) {
+            case "today":
+                // Group by hour (0-23)
+                Map<Integer, Double> hourlyIncome = StatisticsUtils.groupByHour(incomeTransactions);
+                Map<Integer, Double> hourlyExpense = StatisticsUtils.groupByHour(expenseTransactions);
+                
+                for (int hour = 0; hour < 24; hour++) {
+                    incomeEntries.add(new Entry(hour, hourlyIncome.getOrDefault(hour, 0.0).floatValue()));
+                    expenseEntries.add(new Entry(hour, hourlyExpense.getOrDefault(hour, 0.0).floatValue()));
+                    labels.add(StatisticsUtils.formatHourLabel(hour));
+                }
+                break;
+                
+            case "7_days":
+                // Group by day of week
+                Map<String, Double> dailyIncome = StatisticsUtils.groupByDayOfWeek(incomeTransactions);
+                Map<String, Double> dailyExpense = StatisticsUtils.groupByDayOfWeek(expenseTransactions);
+                
+                int dayIndex = 0;
+                for (String day : dailyIncome.keySet()) {
+                    incomeEntries.add(new Entry(dayIndex, dailyIncome.getOrDefault(day, 0.0).floatValue()));
+                    expenseEntries.add(new Entry(dayIndex, dailyExpense.getOrDefault(day, 0.0).floatValue()));
+                    labels.add(day);
+                    dayIndex++;
+                }
+                break;
+                
+            case "1_month":
+                // Group by week in month
+                Map<String, Double> weeklyIncome = StatisticsUtils.groupByWeekInMonth(incomeTransactions);
+                Map<String, Double> weeklyExpense = StatisticsUtils.groupByWeekInMonth(expenseTransactions);
+                
+                List<String> sortedWeeks = new ArrayList<>(weeklyIncome.keySet());
+                Collections.sort(sortedWeeks);
+                
+                for (int i = 0; i < sortedWeeks.size(); i++) {
+                    String week = sortedWeeks.get(i);
+                    incomeEntries.add(new Entry(i, weeklyIncome.getOrDefault(week, 0.0).floatValue()));
+                    expenseEntries.add(new Entry(i, weeklyExpense.getOrDefault(week, 0.0).floatValue()));
+                    labels.add(week);
+                }
+                break;
+                
+            case "6_months":
+                // Group by month
+                Map<String, Double> monthlyIncome = StatisticsUtils.groupByMonth(incomeTransactions);
+                Map<String, Double> monthlyExpense = StatisticsUtils.groupByMonth(expenseTransactions);
+                
+                List<String> sortedMonths = StatisticsUtils.getSortedMonthsLimited(monthlyIncome, 6);
+                
+                for (int i = 0; i < sortedMonths.size(); i++) {
+                    String month = sortedMonths.get(i);
+                    incomeEntries.add(new Entry(i, monthlyIncome.getOrDefault(month, 0.0).floatValue()));
+                    expenseEntries.add(new Entry(i, monthlyExpense.getOrDefault(month, 0.0).floatValue()));
+                    labels.add(StatisticsUtils.formatMonthLabel(month));
+                }
+                break;
+                
+            case "all_time":
+                // Group by year (only show years with transactions)
+                Map<String, Double> yearlyIncome = StatisticsUtils.groupByYear(incomeTransactions);
+                Map<String, Double> yearlyExpense = StatisticsUtils.groupByYear(expenseTransactions);
+                
+                // Only show if there are transactions
+                if (yearlyIncome.isEmpty() && yearlyExpense.isEmpty()) {
+                    if (chartContainer != null) {
+                        chartContainer.setVisibility(View.GONE);
+                    }
+                    return;
+                }
+                
+                List<String> sortedYears = new ArrayList<>(yearlyIncome.keySet());
+                Collections.sort(sortedYears);
+                
+                for (int i = 0; i < sortedYears.size(); i++) {
+                    String year = sortedYears.get(i);
+                    incomeEntries.add(new Entry(i, yearlyIncome.getOrDefault(year, 0.0).floatValue()));
+                    expenseEntries.add(new Entry(i, yearlyExpense.getOrDefault(year, 0.0).floatValue()));
+                    labels.add(year);
+                }
+                break;
+                
+            default:
+                // Default: group by month (6 months)
+                Map<String, Double> defaultMonthlyIncome = StatisticsUtils.groupByMonth(incomeTransactions);
+                Map<String, Double> defaultMonthlyExpense = StatisticsUtils.groupByMonth(expenseTransactions);
+                
+                List<String> defaultSortedMonths = StatisticsUtils.getSortedMonthsLimited(defaultMonthlyIncome, 6);
+                
+                for (int i = 0; i < defaultSortedMonths.size(); i++) {
+                    String month = defaultSortedMonths.get(i);
+                    incomeEntries.add(new Entry(i, defaultMonthlyIncome.getOrDefault(month, 0.0).floatValue()));
+                    expenseEntries.add(new Entry(i, defaultMonthlyExpense.getOrDefault(month, 0.0).floatValue()));
+                    labels.add(StatisticsUtils.formatMonthLabel(month));
+                }
+                break;
+        }
+        
+        android.util.Log.d("HomeActivity", "Chart entries - Income: " + incomeEntries.size() + ", Expense: " + expenseEntries.size() + ", Labels: " + labels.size());
+        
+        if (incomeEntries.isEmpty() && expenseEntries.isEmpty()) {
+            android.util.Log.d("HomeActivity", "No chart entries, hiding chart");
+            if (chartContainer != null) {
+                chartContainer.setVisibility(View.GONE);
+            }
+            return;
+        }
+        
+        // ✅ Log sample values
+        if (!incomeEntries.isEmpty()) {
+            android.util.Log.d("HomeActivity", "Sample income entry: x=" + incomeEntries.get(0).getX() + ", y=" + incomeEntries.get(0).getY());
+        }
+        if (!expenseEntries.isEmpty()) {
+            android.util.Log.d("HomeActivity", "Sample expense entry: x=" + expenseEntries.get(0).getX() + ", y=" + expenseEntries.get(0).getY());
+        }
+
+        LineDataSet incomeSet = new LineDataSet(incomeEntries, getString(R.string.income_label));
         incomeSet.setColor(Color.GREEN);
         incomeSet.setLineWidth(2f);
         incomeSet.setCircleColor(Color.GREEN);
         incomeSet.setCircleRadius(5f);
         incomeSet.setDrawValues(false);
 
-        LineDataSet expenseSet = new LineDataSet(expense, getString(R.string.expense_label));
+        LineDataSet expenseSet = new LineDataSet(expenseEntries, getString(R.string.expense_label));
         expenseSet.setColor(Color.RED);
         expenseSet.setLineWidth(2f);
         expenseSet.setCircleColor(Color.RED);
@@ -752,6 +1001,7 @@
         expenseSet.setDrawValues(false);
 
         LineData data = new LineData(incomeSet, expenseSet);
+        if (lineChart == null) return;
         lineChart.setData(data);
         
         // ✅ Cải thiện UI chart
@@ -760,23 +1010,28 @@
         lineChart.getLegend().setEnabled(true);
         lineChart.getAxisRight().setEnabled(false);
         
-        // ✅ X-axis với labels tháng
+        // ✅ X-axis với labels theo filter type
         XAxis xAxis = lineChart.getXAxis();
-        xAxis.setPosition(XAxis.XAxisPosition.BOTTOM);
-        xAxis.setGranularity(1f);
-        xAxis.setDrawGridLines(false);
-        xAxis.setValueFormatter(new ValueFormatter() {
-            @Override
-            public String getFormattedValue(float value) {
-                int index = (int) value - 1;
-                return (index >= 0 && index < months.length) ? months[index] : "";
-            }
-        });
+        if (xAxis != null) {
+            xAxis.setPosition(XAxis.XAxisPosition.BOTTOM);
+            xAxis.setGranularity(1f);
+            xAxis.setDrawGridLines(false);
+            xAxis.setValueFormatter(new ValueFormatter() {
+                @Override
+                public String getFormattedValue(float value) {
+                    int index = (int) value;
+                    return (index >= 0 && index < labels.size()) ? labels.get(index) : "";
+                }
+            });
+            xAxis.setLabelCount(Math.min(labels.size(), 12), true); // Limit label count
+        }
         
         // ✅ Y-axis
         YAxis leftAxis = lineChart.getAxisLeft();
-        leftAxis.setTextColor(Color.parseColor("#FFFFFF"));
-        leftAxis.setGridColor(Color.parseColor("#33FFFFFF"));
+        if (leftAxis != null) {
+            leftAxis.setTextColor(Color.parseColor("#FFFFFF"));
+            leftAxis.setGridColor(Color.parseColor("#33FFFFFF"));
+        }
         
         lineChart.invalidate(); // Refresh chart
     }
Index: app/src/main/java/com/finmate/ui/auth/LoginActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.finmate.ui.auth;\r\n\r\nimport android.content.Context;\r\nimport android.content.Intent;\r\nimport android.os.Bundle;\r\nimport android.widget.Button;\r\nimport android.widget.EditText;\r\nimport android.widget.TextView;\r\nimport android.widget.Toast;\r\n\r\nimport androidx.appcompat.app.AppCompatActivity;\r\nimport androidx.lifecycle.ViewModelProvider;\r\n\r\nimport com.finmate.R;\r\nimport com.finmate.core.ui.LocaleHelper;\r\nimport com.finmate.ui.home.HomeActivity;\r\n\r\nimport dagger.hilt.android.AndroidEntryPoint;\r\n\r\n@AndroidEntryPoint\r\npublic class LoginActivity extends AppCompatActivity {\r\n\r\n    @Override\r\n    protected void attachBaseContext(Context newBase) {\r\n        super.attachBaseContext(LocaleHelper.applyLocale(newBase));\r\n    }\r\n\r\n    EditText etUsername, etPassword;\r\n    Button btnLogin;\r\n    TextView tvSignup, tvForgot;\r\n    \r\n    private LoginViewModel loginViewModel;\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_login);\r\n\r\n        loginViewModel = new ViewModelProvider(this).get(LoginViewModel.class);\r\n\r\n        // Ánh xạ view\r\n        etUsername = findViewById(R.id.etUsername);\r\n        etPassword = findViewById(R.id.etPassword);\r\n        btnLogin = findViewById(R.id.btnLogin);\r\n        tvSignup = findViewById(R.id.tvSignup);\r\n        tvForgot = findViewById(R.id.tvForgot);\r\n        \r\n        observeViewModel();\r\n\r\n        // Xử lý đăng nhập\r\n        btnLogin.setOnClickListener(v -> {\r\n            String email = etUsername.getText().toString().trim();\r\n            String pass = etPassword.getText().toString().trim();\r\n            \r\n            // Validation\r\n            if (!validateInputs(email, pass)) {\r\n                return;\r\n            }\r\n            \r\n            loginViewModel.login(email, pass);\r\n        });\r\n\r\n        // Chuyển sang SignUp\r\n        tvSignup.setOnClickListener(v -> {\r\n            startActivity(new Intent(LoginActivity.this, SignUpActivity.class));\r\n            overridePendingTransition(android.R.anim.slide_in_left, android.R.anim.slide_out_right);\r\n        });\r\n\r\n        // Forgot password\r\n        tvForgot.setOnClickListener(v ->\r\n                Toast.makeText(this, \"Tính năng đang phát triển\", Toast.LENGTH_SHORT).show()\r\n        );\r\n    }\r\n    \r\n    private boolean validateInputs(String email, String password) {\r\n        boolean isValid = true;\r\n        \r\n        // Validate email\r\n        if (email.isEmpty()) {\r\n            etUsername.setError(getString(R.string.required_field));\r\n            isValid = false;\r\n        } else if (!android.util.Patterns.EMAIL_ADDRESS.matcher(email).matches()) {\r\n            etUsername.setError(getString(R.string.invalid_email));\r\n            isValid = false;\r\n        } else {\r\n            etUsername.setError(null);\r\n        }\r\n        \r\n        // Validate password\r\n        if (password.isEmpty()) {\r\n            etPassword.setError(getString(R.string.required_field));\r\n            isValid = false;\r\n        } else if (password.length() < 6) {\r\n            etPassword.setError(getString(R.string.password_too_short));\r\n            isValid = false;\r\n        } else {\r\n            etPassword.setError(null);\r\n        }\r\n        \r\n        return isValid;\r\n    }\r\n    \r\n    private void observeViewModel() {\r\n        loginViewModel.isLoading.observe(this, isLoading -> {\r\n            btnLogin.setEnabled(!isLoading);\r\n            btnLogin.setText(isLoading ? getString(R.string.syncing) : getString(R.string.login));\r\n            // Show progress indicator\r\n            if (isLoading) {\r\n                // TODO: Show progress bar/dialog if needed\r\n            }\r\n        });\r\n        \r\n        loginViewModel.loginSuccess.observe(this, success -> {\r\n            if (success) {\r\n                Toast.makeText(LoginActivity.this, \"Đăng nhập thành công!\", Toast.LENGTH_SHORT).show();\r\n                startActivity(new Intent(LoginActivity.this, HomeActivity.class));\r\n                overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);\r\n                finish();\r\n            }\r\n        });\r\n        \r\n        loginViewModel.errorMessage.observe(this, error -> {\r\n            if (error != null && !error.isEmpty()) {\r\n                Toast.makeText(LoginActivity.this, error, Toast.LENGTH_SHORT).show();\r\n            }\r\n        });\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/finmate/ui/auth/LoginActivity.java b/app/src/main/java/com/finmate/ui/auth/LoginActivity.java
--- a/app/src/main/java/com/finmate/ui/auth/LoginActivity.java	(revision 156bc616bb4c3d046268d7f0400bef81621c2927)
+++ b/app/src/main/java/com/finmate/ui/auth/LoginActivity.java	(date 1765516945391)
@@ -100,13 +100,26 @@
         return isValid;
     }
     
+    private android.app.ProgressDialog progressDialog;
+
     private void observeViewModel() {
         loginViewModel.isLoading.observe(this, isLoading -> {
             btnLogin.setEnabled(!isLoading);
             btnLogin.setText(isLoading ? getString(R.string.syncing) : getString(R.string.login));
             // Show progress indicator
             if (isLoading) {
-                // TODO: Show progress bar/dialog if needed
+                if (progressDialog == null) {
+                    progressDialog = new android.app.ProgressDialog(this);
+                    progressDialog.setMessage(getString(R.string.syncing));
+                    progressDialog.setCancelable(false);
+                }
+                if (!progressDialog.isShowing()) {
+                    progressDialog.show();
+                }
+            } else {
+                if (progressDialog != null && progressDialog.isShowing()) {
+                    progressDialog.dismiss();
+                }
             }
         });
         
Index: app/src/main/java/com/finmate/ui/activities/AddTransactionActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.finmate.ui.activities;\r\n\r\nimport android.app.DatePickerDialog;\r\nimport android.content.res.Resources;\r\nimport android.graphics.Color;\r\nimport android.os.Bundle;\r\nimport android.text.Editable;\r\nimport android.text.TextWatcher;\r\nimport android.view.LayoutInflater;\r\nimport android.view.View;\r\nimport android.widget.Button;\r\nimport android.widget.EditText;\r\nimport android.widget.ImageView;\r\nimport android.widget.LinearLayout;\r\nimport android.widget.TextView;\r\nimport android.widget.Toast;\r\nimport com.finmate.ui.base.BaseActivity;\r\n\r\nimport androidx.appcompat.app.AppCompatActivity;\r\n\r\nimport com.finmate.R;\r\nimport com.finmate.core.network.ApiCallback;\r\nimport com.finmate.core.network.NetworkChecker;\r\nimport com.finmate.data.dto.CategoryResponse;\r\nimport com.finmate.data.dto.TransactionResponse;\r\nimport com.finmate.data.local.database.entity.CategoryEntity;\r\nimport com.finmate.data.local.database.entity.TransactionEntity;\r\nimport com.finmate.data.local.database.entity.WalletEntity;\r\nimport com.finmate.data.remote.dto.CreateTransactionRequest;\r\nimport com.finmate.data.repository.CategoryRepository;\r\nimport com.finmate.data.repository.CategoryRemoteRepository;\r\nimport com.finmate.data.repository.TransactionRemoteRepository;\r\nimport com.finmate.data.repository.TransactionRepository;\r\nimport com.finmate.data.repository.WalletRepository;\r\nimport com.google.android.material.bottomsheet.BottomSheetDialog;\r\n\r\nimport java.math.BigDecimal;\r\nimport java.text.SimpleDateFormat;\r\nimport java.time.Instant;\r\nimport java.time.format.DateTimeFormatter;\r\nimport java.util.ArrayList;\r\nimport java.util.Calendar;\r\nimport java.util.List;\r\nimport java.util.Locale;\r\n\r\nimport javax.inject.Inject;\r\n\r\nimport dagger.hilt.android.AndroidEntryPoint;\r\n\r\n@AndroidEntryPoint\r\npublic class AddTransactionActivity extends BaseActivity {\r\n\r\n    @Inject\r\n    CategoryRepository categoryRepository;\r\n    \r\n    @Inject\r\n    CategoryRemoteRepository categoryRemoteRepository;\r\n    \r\n    @Inject\r\n    WalletRepository walletRepository;\r\n    \r\n    @Inject\r\n    TransactionRepository transactionRepository;\r\n    \r\n    @Inject\r\n    TransactionRemoteRepository transactionRemoteRepository;\r\n    \r\n    @Inject\r\n    NetworkChecker networkChecker;\r\n\r\n    EditText etGroup, etCategory, etTitle, etAmount, etWallet, etNote;\r\n    TextView tvDate, tvAddTitle;\r\n    Button btnCancel, btnSave;\r\n    ImageView btnDelete; // Nút xóa khi edit mode\r\n\r\n    String selectedGroup = \"\"; // \"INCOME\" hoặc \"EXPENSE\"\r\n    String selectedCategoryId = null;\r\n    String selectedCategoryName = null;\r\n    String selectedWalletId = null;\r\n    String selectedWalletName = null;\r\n    boolean isEditMode = false;\r\n    String transactionId = null; // ID của transaction đang edit\r\n\r\n    // Ngày\r\n    String startDate = \"\";\r\n    String endDate = \"\";\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_add_transaction);\r\n\r\n        initViews();\r\n        setupEvents();\r\n    }\r\n\r\n    private void initViews() {\r\n        etGroup    = findViewById(R.id.etGroup);\r\n        etCategory = findViewById(R.id.etCategory);\r\n        etTitle    = findViewById(R.id.etTitle);\r\n        etAmount   = findViewById(R.id.etAmount);\r\n        etWallet   = findViewById(R.id.etWallet);\r\n        tvDate     = findViewById(R.id.tvDate);\r\n        etNote     = findViewById(R.id.etNote);\r\n        tvAddTitle = findViewById(R.id.tvAddTitle);\r\n\r\n        btnCancel  = findViewById(R.id.btnCancel);\r\n        btnSave    = findViewById(R.id.btnSave);\r\n\r\n        // Check if edit mode\r\n        transactionId = getIntent().getStringExtra(\"transaction_id\");\r\n        if (transactionId != null && !transactionId.isEmpty()) {\r\n            isEditMode = true;\r\n            if (tvAddTitle != null) {\r\n                tvAddTitle.setText(R.string.edit_transaction);\r\n            }\r\n            // TODO: Load transaction data và populate fields\r\n        } else {\r\n            isEditMode = false;\r\n            if (tvAddTitle != null) {\r\n                tvAddTitle.setText(R.string.add_transaction_title);\r\n            }\r\n        }\r\n    }\r\n\r\n    // ✅ Xóa TextWatcher đổi màu cứng - dùng theme thay thế\r\n    // EditText đã được config textColor và textColorHint trong XML\r\n\r\n    private void setupEvents() {\r\n        // Field 1: Nhóm giao dịch (INCOME/EXPENSE)\r\n        etGroup.setOnClickListener(v -> showGroupBottomSheet());\r\n\r\n        // Field 2: Danh mục (Ăn uống, Lương...)\r\n        etCategory.setOnClickListener(v -> {\r\n            if (selectedGroup.isEmpty()) {\r\n                Toast.makeText(this, \"Hãy chọn nhóm giao dịch trước!\", Toast.LENGTH_SHORT).show();\r\n                return;\r\n            }\r\n            showCategoryItemsBottomSheet();\r\n        });\r\n\r\n        // Field 3: Tên giao dịch - cho gõ tự do, auto-fill theo category nhưng có thể chỉnh\r\n        // Không cần click listener, user có thể gõ tự do\r\n\r\n        etWallet.setOnClickListener(v -> showWalletBottomSheet());\r\n\r\n        // Chọn ngày giao dịch\r\n        tvDate.setOnClickListener(v -> showDueDateBottomSheet());\r\n\r\n        btnCancel.setOnClickListener(v -> finish());\r\n\r\n        btnSave.setOnClickListener(v -> saveTransaction());\r\n    }\r\n\r\n    // ================================\r\n    // 1) BottomSheet: Chọn nhóm\r\n    // ================================\r\n    private void showGroupBottomSheet() {\r\n\r\n        BottomSheetDialog dialog = new BottomSheetDialog(this);\r\n        View view = LayoutInflater.from(this).inflate(R.layout.bottom_sheet_group, null);\r\n\r\n        TextView tvIncome  = view.findViewById(R.id.tvIncomeGroup);\r\n        TextView tvExpense = view.findViewById(R.id.tvExpenseGroup);\r\n\r\n        tvIncome.setOnClickListener(v -> {\r\n            selectedGroup = \"INCOME\";\r\n            etGroup.setText(getString(R.string.income_label));\r\n            etCategory.setText(\"\"); // Clear category khi đổi nhóm\r\n            // Auto-fill title nếu đang rỗng, nếu đã có text thì giữ nguyên\r\n            if (etTitle.getText().toString().trim().isEmpty()) {\r\n                etTitle.setText(\"\");\r\n            }\r\n            selectedCategoryId = null;\r\n            selectedCategoryName = null;\r\n            dialog.dismiss();\r\n        });\r\n\r\n        tvExpense.setOnClickListener(v -> {\r\n            selectedGroup = \"EXPENSE\";\r\n            etGroup.setText(getString(R.string.expense_label));\r\n            etCategory.setText(\"\"); // Clear category khi đổi nhóm\r\n            // Auto-fill title nếu đang rỗng, nếu đã có text thì giữ nguyên\r\n            if (etTitle.getText().toString().trim().isEmpty()) {\r\n                etTitle.setText(\"\");\r\n            }\r\n            selectedCategoryId = null;\r\n            selectedCategoryName = null;\r\n            dialog.dismiss();\r\n        });\r\n\r\n        dialog.setContentView(view);\r\n        dialog.show();\r\n    }\r\n\r\n    // ================================\r\n    // 2) BottomSheet: Mục con - Load từ database\r\n    // ================================\r\n    private void showCategoryItemsBottomSheet() {\r\n        if (selectedGroup.isEmpty() || (!selectedGroup.equals(\"INCOME\") && !selectedGroup.equals(\"EXPENSE\"))) {\r\n            Toast.makeText(this, \"Hãy chọn nhóm giao dịch trước!\", Toast.LENGTH_SHORT).show();\r\n            return;\r\n        }\r\n\r\n        BottomSheetDialog dialog = new BottomSheetDialog(this);\r\n        View view = LayoutInflater.from(this).inflate(R.layout.bottom_sheet_category_items, null);\r\n\r\n        LinearLayout container = view.findViewById(R.id.layoutCategoryItems);\r\n        container.removeAllViews();\r\n\r\n        // ✅ Load categories từ database theo type\r\n        // Sử dụng selectedGroup trực tiếp (uppercase) vì CategoryEntity có thể lưu cả uppercase và lowercase\r\n        // Nếu không tìm thấy, thử lowercase\r\n        String type = selectedGroup; // \"INCOME\" hoặc \"EXPENSE\"\r\n        categoryRepository.getByType(type).observe(this, categories -> {\r\n            if (categories == null || categories.isEmpty()) {\r\n                // Thử lowercase nếu không tìm thấy\r\n                String typeLower = selectedGroup.toLowerCase();\r\n                categoryRepository.getByType(typeLower).observe(this, categoriesLower -> {\r\n                    if (categoriesLower == null || categoriesLower.isEmpty()) {\r\n                        // Nếu chưa có categories, sync từ backend\r\n                        categoryRepository.fetchRemoteCategoriesByType(selectedGroup);\r\n                        return;\r\n                    }\r\n                    displayCategories(categoriesLower, container, dialog);\r\n                });\r\n                return;\r\n            }\r\n            displayCategories(categories, container, dialog);\r\n        });\r\n\r\n        dialog.setContentView(view);\r\n        dialog.show();\r\n    }\r\n\r\n    private void displayCategories(List<CategoryEntity> categories, LinearLayout container, BottomSheetDialog dialog) {\r\n        container.removeAllViews();\r\n\r\n        for (CategoryEntity category : categories) {\r\n            // ✅ Tạo item view với icon và tên\r\n            View itemView = createCategoryItemView(category, dialog);\r\n            container.addView(itemView);\r\n        }\r\n    }\r\n\r\n    // ✅ Tạo view cho mỗi category item (có icon và tên)\r\n    private View createCategoryItemView(CategoryEntity category, BottomSheetDialog dialog) {\r\n        LinearLayout itemLayout = new LinearLayout(this);\r\n        itemLayout.setOrientation(LinearLayout.HORIZONTAL);\r\n        itemLayout.setPadding(32, 32, 32, 32);\r\n        itemLayout.setBackgroundResource(android.R.drawable.list_selector_background);\r\n        itemLayout.setGravity(android.view.Gravity.CENTER_VERTICAL);\r\n\r\n        // ✅ Icon\r\n        ImageView iconView = new ImageView(this);\r\n        int iconResId = getIconResourceId(category.getIcon());\r\n        iconView.setImageResource(iconResId);\r\n        iconView.setLayoutParams(new LinearLayout.LayoutParams(48, 48));\r\n        iconView.setPadding(0, 0, 16, 0);\r\n        itemLayout.addView(iconView);\r\n\r\n        // ✅ Category name\r\n        TextView tvName = new TextView(this);\r\n        tvName.setText(category.getName());\r\n        tvName.setTextSize(17);\r\n        tvName.setTextColor(Color.WHITE);\r\n        tvName.setLayoutParams(new LinearLayout.LayoutParams(\r\n                LinearLayout.LayoutParams.WRAP_CONTENT,\r\n                LinearLayout.LayoutParams.WRAP_CONTENT\r\n        ));\r\n        itemLayout.addView(tvName);\r\n\r\n        // ✅ Click listener\r\n        itemLayout.setOnClickListener(v -> {\r\n            // Set category name\r\n            selectedCategoryName = category.getName();\r\n            etCategory.setText(category.getName());\r\n            \r\n            // ✅ Auto-fill Title nếu đang rỗng, nếu đã có text thì giữ nguyên\r\n            if (etTitle.getText().toString().trim().isEmpty()) {\r\n                etTitle.setText(category.getName());\r\n            }\r\n            \r\n            dialog.dismiss();\r\n            \r\n            // ✅ Lấy categoryId từ local DB (nếu có remoteId) hoặc query từ backend\r\n            // TODO: Cần thêm remoteId vào CategoryEntity để lưu categoryId từ backend\r\n            // Hiện tại vẫn query từ backend async\r\n            fetchCategoryIdFromBackend(category.getName(), category.getType());\r\n        });\r\n\r\n        return itemLayout;\r\n    }\r\n\r\n    // ✅ Helper method để lấy icon resource ID từ icon name\r\n    private int getIconResourceId(String iconName) {\r\n        if (iconName == null || iconName.isEmpty()) {\r\n            return R.drawable.ic_default_category;\r\n        }\r\n\r\n        Resources resources = getResources();\r\n        String packageName = getPackageName();\r\n        String trimmedName = iconName.trim();\r\n        int resId = resources.getIdentifier(trimmedName, \"drawable\", packageName);\r\n\r\n        // Nếu không tìm thấy, thử lowercase\r\n        if (resId == 0) {\r\n            resId = resources.getIdentifier(trimmedName.toLowerCase(), \"drawable\", packageName);\r\n        }\r\n\r\n        return resId != 0 ? resId : R.drawable.ic_default_category;\r\n    }\r\n\r\n    // ✅ Fetch categoryId from backend by category name (async, không block UI)\r\n    private void fetchCategoryIdFromBackend(String categoryName, String categoryType) {\r\n        if (!networkChecker.isNetworkAvailable()) {\r\n            // No network - categoryId will be null, but categoryName is already set\r\n            selectedCategoryId = null;\r\n            return;\r\n        }\r\n\r\n        // Query categories from backend to find categoryId (async)\r\n        categoryRemoteRepository.fetchCategoriesByType(categoryType, new ApiCallback<List<CategoryResponse>>() {\r\n            @Override\r\n            public void onSuccess(List<CategoryResponse> categories) {\r\n                if (categories != null) {\r\n                    for (CategoryResponse cat : categories) {\r\n                        if (cat.getName().equals(categoryName)) {\r\n                            selectedCategoryId = cat.getId();\r\n                            // categoryName and etTitle are already set, no need to update UI\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n                // Category not found - categoryId will be null, but categoryName is already set\r\n                selectedCategoryId = null;\r\n            }\r\n\r\n            @Override\r\n            public void onError(String message) {\r\n                // Error fetching - categoryId will be null, but categoryName is already set\r\n                selectedCategoryId = null;\r\n            }\r\n        });\r\n    }\r\n\r\n    // ================================\r\n    // 3) BottomSheet: Danh sách ví\r\n    // ================================\r\n    private void showWalletBottomSheet() {\r\n        BottomSheetDialog dialog = new BottomSheetDialog(this);\r\n        View view = LayoutInflater.from(this).inflate(R.layout.bottom_sheet_friends, null);\r\n\r\n        LinearLayout container = view.findViewById(R.id.layoutFriendItems);\r\n        TextView tvNone = view.findViewById(R.id.tvFriendNone);\r\n        \r\n        // Đổi text \"Không có bạn\" thành \"Không chọn\"\r\n        tvNone.setText(\"Không chọn\");\r\n\r\n        container.removeAllViews();\r\n\r\n        // ✅ Load wallets từ database\r\n        walletRepository.getAll(new WalletRepository.Callback() {\r\n            @Override\r\n            public void onResult(List<WalletEntity> wallets) {\r\n                if (wallets == null || wallets.isEmpty()) {\r\n                    Toast.makeText(AddTransactionActivity.this, getString(R.string.no_wallets), Toast.LENGTH_SHORT).show();\r\n                    dialog.dismiss();\r\n                    return;\r\n                }\r\n\r\n                // Tạo TextView cho mỗi wallet\r\n                for (WalletEntity wallet : wallets) {\r\n                    TextView tv = new TextView(AddTransactionActivity.this);\r\n                    tv.setText(wallet.name);\r\n                    tv.setTextSize(17);\r\n                    tv.setPadding(32, 32, 32, 32);\r\n                    tv.setTextColor(Color.WHITE);\r\n                    tv.setBackgroundResource(android.R.drawable.list_selector_background);\r\n\r\n                    tv.setOnClickListener(v -> {\r\n                        selectedWalletId = wallet.id;\r\n                        selectedWalletName = wallet.name;\r\n                        etWallet.setText(wallet.name);\r\n                        etWallet.setTextColor(Color.BLACK);\r\n                        dialog.dismiss();\r\n                    });\r\n\r\n                    container.addView(tv);\r\n                }\r\n            }\r\n        });\r\n\r\n        tvNone.setOnClickListener(v -> {\r\n            selectedWalletId = null;\r\n            selectedWalletName = null;\r\n            etWallet.setText(\"\");\r\n            etWallet.setTextColor(Color.WHITE);\r\n            dialog.dismiss();\r\n        });\r\n\r\n        dialog.setContentView(view);\r\n        dialog.show();\r\n    }\r\n\r\n    // ================================\r\n    // 4) BottomSheet: Chọn ngày\r\n    // ================================\r\n    private void showDueDateBottomSheet() {\r\n\r\n        BottomSheetDialog dialog = new BottomSheetDialog(this);\r\n        View view = LayoutInflater.from(this).inflate(R.layout.bottom_sheet_due_date, null);\r\n\r\n        TextView tvToday  = view.findViewById(R.id.tvDueToday);\r\n        TextView tvSingle = view.findViewById(R.id.tvDueSingle);\r\n        TextView tvRange  = view.findViewById(R.id.tvDueRange);\r\n        TextView tvClear  = view.findViewById(R.id.tvDueClear);\r\n\r\n        // 1) Trong ngày\r\n        tvToday.setOnClickListener(v -> {\r\n            Calendar c = Calendar.getInstance();\r\n            int y = c.get(Calendar.YEAR);\r\n            int m = c.get(Calendar.MONTH) + 1;\r\n            int d = c.get(Calendar.DAY_OF_MONTH);\r\n\r\n            tvDate.setText(d + \"/\" + m + \"/\" + y);\r\n            tvDate.setTextColor(Color.BLACK);\r\n            dialog.dismiss();\r\n        });\r\n\r\n        // 2) Chọn 1 ngày\r\n        tvSingle.setOnClickListener(v -> {\r\n            dialog.dismiss();\r\n            showSingleDatePicker();\r\n        });\r\n\r\n        // 3) Chọn từ → đến\r\n        tvRange.setOnClickListener(v -> {\r\n            dialog.dismiss();\r\n            showStartDatePicker();\r\n        });\r\n\r\n        // 4) Xóa\r\n        tvClear.setOnClickListener(v -> {\r\n            tvDate.setText(\"Ngày giao dịch\");\r\n            tvDate.setTextColor(getResources().getColor(android.R.color.darker_gray));\r\n            startDate = \"\";\r\n            endDate = \"\";\r\n            dialog.dismiss();\r\n        });\r\n\r\n        dialog.setContentView(view);\r\n        dialog.show();\r\n    }\r\n\r\n    // 1 NGÀY\r\n    private void showSingleDatePicker() {\r\n        Calendar c = Calendar.getInstance();\r\n\r\n        DatePickerDialog picker = new DatePickerDialog(\r\n                this,\r\n                (view, y, m, d) -> {\r\n                    tvDate.setText(d + \"/\" + (m + 1) + \"/\" + y);\r\n                    tvDate.setTextColor(Color.BLACK);\r\n                },\r\n                c.get(Calendar.YEAR),\r\n                c.get(Calendar.MONTH),\r\n                c.get(Calendar.DAY_OF_MONTH)\r\n        );\r\n\r\n        picker.setTitle(\"Chọn ngày\");\r\n        picker.show();\r\n    }\r\n\r\n    // CHỌN TỪ NGÀY\r\n    private void showStartDatePicker() {\r\n\r\n        Calendar c = Calendar.getInstance();\r\n\r\n        DatePickerDialog picker = new DatePickerDialog(\r\n                this,\r\n                (view, y, m, d) -> {\r\n                    startDate = d + \"/\" + (m + 1) + \"/\" + y;\r\n                    showEndDatePicker();\r\n                },\r\n                c.get(Calendar.YEAR),\r\n                c.get(Calendar.MONTH),\r\n                c.get(Calendar.DAY_OF_MONTH)\r\n        );\r\n\r\n        picker.setTitle(\"Chọn ngày bắt đầu\");\r\n        picker.show();\r\n    }\r\n\r\n    // CHỌN ĐẾN NGÀY\r\n    private void showEndDatePicker() {\r\n\r\n        Calendar c = Calendar.getInstance();\r\n\r\n        DatePickerDialog picker = new DatePickerDialog(\r\n                this,\r\n                (view, y, m, d) -> {\r\n                    endDate = d + \"/\" + (m + 1) + \"/\" + y;\r\n\r\n                    tvDate.setText(startDate + \" → \" + endDate);\r\n                    tvDate.setTextColor(Color.BLACK);\r\n                },\r\n                c.get(Calendar.YEAR),\r\n                c.get(Calendar.MONTH),\r\n                c.get(Calendar.DAY_OF_MONTH)\r\n        );\r\n\r\n        picker.setTitle(\"Chọn ngày kết thúc\");\r\n        picker.show();\r\n    }\r\n\r\n    // ================================\r\n    // 5) Lưu giao dịch\r\n    // ================================\r\n    private boolean validateInputs() {\r\n        boolean isValid = true;\r\n\r\n        // Validate group\r\n        if (selectedGroup.isEmpty() || etGroup.getText().toString().trim().isEmpty()) {\r\n            etGroup.setError(getString(R.string.required_field));\r\n            isValid = false;\r\n        } else {\r\n            etGroup.setError(null);\r\n        }\r\n\r\n        // Validate category\r\n        if (selectedCategoryName == null || etCategory.getText().toString().trim().isEmpty()) {\r\n            etCategory.setError(getString(R.string.required_field));\r\n            isValid = false;\r\n        } else {\r\n            etCategory.setError(null);\r\n        }\r\n\r\n        // Validate title - không bắt buộc, nhưng nếu rỗng thì dùng category name\r\n        String title = etTitle.getText().toString().trim();\r\n        if (title.isEmpty() && selectedCategoryName != null) {\r\n            title = selectedCategoryName; // Auto-fill từ category nếu rỗng\r\n        }\r\n        etTitle.setError(null);\r\n\r\n        // Validate amount - thống nhất parse logic\r\n        String amountStr = etAmount.getText().toString().trim();\r\n        if (amountStr.isEmpty()) {\r\n            etAmount.setError(getString(R.string.required_field));\r\n            isValid = false;\r\n        } else {\r\n            try {\r\n                // ✅ Thống nhất: loại bỏ tất cả ký tự không phải số (VND không có phần lẻ)\r\n                String cleanedAmount = amountStr.replaceAll(\"[^0-9]\", \"\");\r\n                if (cleanedAmount.isEmpty()) {\r\n                    etAmount.setError(getString(R.string.amount_invalid));\r\n                    isValid = false;\r\n                } else {\r\n                    long amount = Long.parseLong(cleanedAmount);\r\n                    if (amount <= 0) {\r\n                        etAmount.setError(getString(R.string.amount_invalid));\r\n                        isValid = false;\r\n                    } else {\r\n                        etAmount.setError(null);\r\n                    }\r\n                }\r\n            } catch (NumberFormatException e) {\r\n                etAmount.setError(getString(R.string.amount_invalid));\r\n                isValid = false;\r\n            }\r\n        }\r\n\r\n        // ✅ Validate wallet\r\n        if (selectedWalletId == null || selectedWalletName == null || etWallet.getText().toString().trim().isEmpty()) {\r\n            etWallet.setError(getString(R.string.required_field));\r\n            isValid = false;\r\n        } else {\r\n            etWallet.setError(null);\r\n        }\r\n\r\n        if (!isValid) {\r\n            Toast.makeText(this, R.string.fill_all_info, Toast.LENGTH_SHORT).show();\r\n        }\r\n\r\n        return isValid;\r\n    }\r\n\r\n    private void saveTransaction() {\r\n        // Validate inputs\r\n        if (!validateInputs()) {\r\n            return;\r\n        }\r\n\r\n        String title = etTitle.getText().toString().trim();\r\n        // ✅ Nếu title rỗng, dùng category name\r\n        if (title.isEmpty() && selectedCategoryName != null) {\r\n            title = selectedCategoryName;\r\n        }\r\n        String amountStr = etAmount.getText().toString().trim();\r\n        String note = etNote.getText().toString().trim();\r\n\r\n        // ✅ Parse amount - thống nhất với validateInputs()\r\n        double amountDouble;\r\n        try {\r\n            // Loại bỏ tất cả ký tự không phải số (VND không có phần lẻ)\r\n            String cleanedAmount = amountStr.replaceAll(\"[^0-9]\", \"\");\r\n            if (cleanedAmount.isEmpty()) {\r\n                Toast.makeText(this, getString(R.string.amount_invalid), Toast.LENGTH_SHORT).show();\r\n                return;\r\n            }\r\n            amountDouble = Long.parseLong(cleanedAmount);\r\n        } catch (NumberFormatException e) {\r\n            Toast.makeText(this, getString(R.string.amount_invalid), Toast.LENGTH_SHORT).show();\r\n            return;\r\n        }\r\n\r\n        // Format amount string for display\r\n        String amountFormatted = String.format(Locale.getDefault(), \"%,.0f\", amountDouble);\r\n\r\n        // Parse date\r\n        String dateStr = tvDate.getText().toString().trim();\r\n        String dateISO = \"\";\r\n        \r\n        if (dateStr.isEmpty() || dateStr.equals(\"Ngày giao dịch\") || dateStr.equals(getString(R.string.due_date))) {\r\n            // Use current date if not selected\r\n            Calendar c = Calendar.getInstance();\r\n            SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\", Locale.getDefault());\r\n            dateISO = sdf.format(c.getTime());\r\n        } else {\r\n            // Parse from display format (dd/MM/yyyy) to ISO (yyyy-MM-dd)\r\n            try {\r\n                SimpleDateFormat displayFormat = new SimpleDateFormat(\"dd/MM/yyyy\", Locale.getDefault());\r\n                SimpleDateFormat isoFormat = new SimpleDateFormat(\"yyyy-MM-dd\", Locale.getDefault());\r\n                \r\n                // Handle date range format (start → end)\r\n                if (dateStr.contains(\"→\")) {\r\n                    String[] parts = dateStr.split(\"→\");\r\n                    if (parts.length == 2) {\r\n                        dateStr = parts[0].trim(); // Use start date\r\n                    }\r\n                }\r\n                \r\n                java.util.Date date = displayFormat.parse(dateStr);\r\n                if (date != null) {\r\n                    dateISO = isoFormat.format(date);\r\n                } else {\r\n                    dateISO = dateStr; // Fallback to original\r\n                }\r\n            } catch (Exception e) {\r\n                // If parsing fails, use current date\r\n                Calendar c = Calendar.getInstance();\r\n                SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\", Locale.getDefault());\r\n                dateISO = sdf.format(c.getTime());\r\n            }\r\n        }\r\n\r\n        // Create TransactionEntity for local storage\r\n        TransactionEntity transaction = new TransactionEntity(\r\n                title,                                    // name\r\n                selectedCategoryName != null ? selectedCategoryName : \"\", // category\r\n                amountFormatted,                          // amount (formatted string)\r\n                selectedWalletName != null ? selectedWalletName : \"\", // wallet\r\n                dateISO,                                 // date (ISO format)\r\n                selectedGroup,                            // type (INCOME/EXPENSE)\r\n                amountDouble                              // amountDouble\r\n        );\r\n\r\n        // Save to local database first (offline-first)\r\n        transactionRepository.insert(transaction);\r\n\r\n        // ✅ Transaction đã được lưu local → sẽ hiện ra Home ngay khi quay lại\r\n        // ✅ Try to sync with backend ngay nếu có mạng và đủ thông tin\r\n        if (networkChecker.isNetworkAvailable() && selectedWalletId != null && selectedCategoryId != null) {\r\n            syncTransactionToBackend(transaction, dateISO, note);\r\n        } else {\r\n            // No network or missing IDs - transaction vẫn được lưu local\r\n            // Sẽ tự động sync sau khi có mạng (qua TransactionSyncManager)\r\n            if (isEditMode) {\r\n                Toast.makeText(this, \"Đã cập nhật giao dịch!\", Toast.LENGTH_SHORT).show();\r\n            } else {\r\n                Toast.makeText(this, R.string.transaction_saved, Toast.LENGTH_SHORT).show();\r\n            }\r\n            finish();\r\n        }\r\n    }\r\n\r\n    private void syncTransactionToBackend(TransactionEntity transaction, String dateISO, String note) {\r\n        // Convert dateISO (yyyy-MM-dd) to ISO datetime string (yyyy-MM-dd'T'HH:mm:ss)\r\n        String occurredAtISO = dateISO + \"T00:00:00\";\r\n        \r\n        // Create request\r\n        CreateTransactionRequest request = new CreateTransactionRequest(\r\n                selectedWalletId,\r\n                selectedCategoryId,\r\n                selectedGroup,\r\n                BigDecimal.valueOf(transaction.amountDouble),\r\n                \"VND\", // Default currency\r\n                occurredAtISO,\r\n                note, // ✅ Gửi đúng note từ etNote\r\n                null // transferRefId\r\n        );\r\n\r\n        transactionRemoteRepository.createTransaction(request, new ApiCallback<TransactionResponse>() {\r\n            @Override\r\n            public void onSuccess(TransactionResponse response) {\r\n                // Transaction synced successfully\r\n                runOnUiThread(() -> {\r\n                    if (isEditMode) {\r\n                        Toast.makeText(AddTransactionActivity.this, \"Đã cập nhật giao dịch!\", Toast.LENGTH_SHORT).show();\r\n                    } else {\r\n                        Toast.makeText(AddTransactionActivity.this, R.string.transaction_saved, Toast.LENGTH_SHORT).show();\r\n                    }\r\n                    finish();\r\n                });\r\n            }\r\n\r\n            @Override\r\n            public void onError(String message) {\r\n                // Sync failed, but transaction is already saved locally\r\n                runOnUiThread(() -> {\r\n                    Toast.makeText(AddTransactionActivity.this, \"Đã lưu (chưa đồng bộ)\", Toast.LENGTH_SHORT).show();\r\n                    finish();\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/finmate/ui/activities/AddTransactionActivity.java b/app/src/main/java/com/finmate/ui/activities/AddTransactionActivity.java
--- a/app/src/main/java/com/finmate/ui/activities/AddTransactionActivity.java	(revision 156bc616bb4c3d046268d7f0400bef81621c2927)
+++ b/app/src/main/java/com/finmate/ui/activities/AddTransactionActivity.java	(date 1765517193900)
@@ -114,7 +114,8 @@
             if (tvAddTitle != null) {
                 tvAddTitle.setText(R.string.edit_transaction);
             }
-            // TODO: Load transaction data và populate fields
+            // Load transaction data và populate fields
+            loadTransactionData();
         } else {
             isEditMode = false;
             if (tvAddTitle != null) {
@@ -126,6 +127,103 @@
     // ✅ Xóa TextWatcher đổi màu cứng - dùng theme thay thế
     // EditText đã được config textColor và textColorHint trong XML
 
+    private void loadTransactionData() {
+        try {
+            int id = Integer.parseInt(transactionId);
+            transactionRepository.getById(id, new TransactionRepository.OnResultCallback<TransactionEntity>() {
+                @Override
+                public void onResult(TransactionEntity transaction) {
+                    if (transaction != null) {
+                        runOnUiThread(() -> populateFields(transaction));
+                    }
+                }
+            });
+        } catch (NumberFormatException e) {
+            Toast.makeText(this, "Lỗi: ID giao dịch không hợp lệ", Toast.LENGTH_SHORT).show();
+        }
+    }
+
+    private void populateFields(TransactionEntity transaction) {
+        // Set group (INCOME/EXPENSE)
+        if (transaction.type != null) {
+            selectedGroup = transaction.type;
+            if (transaction.type.equals("INCOME")) {
+                etGroup.setText(getString(R.string.income_label));
+            } else if (transaction.type.equals("EXPENSE")) {
+                etGroup.setText(getString(R.string.expense_label));
+            }
+        }
+
+        // Set category
+        if (transaction.category != null && !transaction.category.isEmpty()) {
+            selectedCategoryName = transaction.category;
+            etCategory.setText(transaction.category);
+            // Fetch category ID from backend if needed
+            fetchCategoryIdFromBackend(transaction.category, selectedGroup);
+        }
+
+        // Set title
+        if (transaction.name != null) {
+            etTitle.setText(transaction.name);
+        }
+
+        // Set amount - remove formatting for display
+        if (transaction.amountDouble > 0) {
+            String amountStr = String.format(Locale.getDefault(), "%.0f", transaction.amountDouble);
+            etAmount.setText(amountStr);
+        } else if (transaction.amount != null && !transaction.amount.isEmpty()) {
+            // Try to parse from formatted string
+            String cleanedAmount = transaction.amount.replaceAll("[^0-9]", "");
+            if (!cleanedAmount.isEmpty()) {
+                etAmount.setText(cleanedAmount);
+            }
+        }
+
+        // Set wallet
+        if (transaction.wallet != null && !transaction.wallet.isEmpty()) {
+            selectedWalletName = transaction.wallet;
+            etWallet.setText(transaction.wallet);
+            // Try to find wallet ID
+            walletRepository.getAll(new WalletRepository.Callback() {
+                @Override
+                public void onResult(List<WalletEntity> wallets) {
+                    if (wallets != null && !wallets.isEmpty()) {
+                        for (WalletEntity wallet : wallets) {
+                            if (wallet.name != null && wallet.name.equals(transaction.wallet)) {
+                                runOnUiThread(() -> {
+                                    selectedWalletId = wallet.id;
+                                });
+                                break;
+                            }
+                        }
+                    }
+                }
+            });
+        }
+
+        // Set date
+        if (transaction.date != null && !transaction.date.isEmpty()) {
+            try {
+                // Parse ISO format (yyyy-MM-dd) to display format (dd/MM/yyyy)
+                SimpleDateFormat isoFormat = new SimpleDateFormat("yyyy-MM-dd", Locale.getDefault());
+                SimpleDateFormat displayFormat = new SimpleDateFormat("dd/MM/yyyy", Locale.getDefault());
+                java.util.Date date = isoFormat.parse(transaction.date);
+                if (date != null) {
+                    String dateDisplay = displayFormat.format(date);
+                    tvDate.setText(dateDisplay);
+                    tvDate.setTextColor(Color.BLACK);
+                }
+            } catch (Exception e) {
+                // If parsing fails, use the date string as is
+                tvDate.setText(transaction.date);
+                tvDate.setTextColor(Color.BLACK);
+            }
+        }
+
+        // Set note (if available - note is not stored in TransactionEntity, only synced to backend)
+        // Note field would need to be added to TransactionEntity to persist locally
+    }
+
     private void setupEvents() {
         // Field 1: Nhóm giao dịch (INCOME/EXPENSE)
         etGroup.setOnClickListener(v -> showGroupBottomSheet());
@@ -665,16 +763,30 @@
                 amountDouble                              // amountDouble
         );
 
-        // Save to local database first (offline-first)
-        transactionRepository.insert(transaction);
+        // If edit mode, set the ID and update; otherwise insert
+        if (isEditMode && transactionId != null) {
+            try {
+                transaction.id = Integer.parseInt(transactionId);
+                transactionRepository.update(transaction);
+            } catch (NumberFormatException e) {
+                // If ID is invalid, insert as new transaction
+                transactionRepository.insert(transaction);
+            }
+        } else {
+            // Save to local database first (offline-first)
+            transactionRepository.insert(transaction);
+        }
 
         // ✅ Transaction đã được lưu local → sẽ hiện ra Home ngay khi quay lại
         // ✅ Try to sync with backend ngay nếu có mạng và đủ thông tin
-        if (networkChecker.isNetworkAvailable() && selectedWalletId != null && selectedCategoryId != null) {
+        // Note: Khi edit mode, chỉ sync nếu transaction chưa có remoteId (chưa sync lần đầu)
+        // Nếu đã có remoteId, cần có update API để update, không nên create lại
+        if (!isEditMode && networkChecker.isNetworkAvailable() && selectedWalletId != null && selectedCategoryId != null) {
+            // Chỉ sync khi tạo mới, không sync khi edit (tránh tạo duplicate)
             syncTransactionToBackend(transaction, dateISO, note);
         } else {
-            // No network or missing IDs - transaction vẫn được lưu local
-            // Sẽ tự động sync sau khi có mạng (qua TransactionSyncManager)
+            // No network, missing IDs, or edit mode - transaction vẫn được lưu local
+            // Sẽ tự động sync sau khi có mạng (qua TransactionSyncManager) hoặc khi có update API
             if (isEditMode) {
                 Toast.makeText(this, "Đã cập nhật giao dịch!", Toast.LENGTH_SHORT).show();
             } else {
Index: app/src/main/java/com/finmate/data/local/database/dao/TransactionDao.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.finmate.data.local.database.dao;\r\n\r\nimport androidx.room.Dao;\r\nimport androidx.room.Delete;\r\nimport androidx.room.Insert;\r\nimport androidx.room.Query;\r\nimport androidx.room.Update;\r\n\r\nimport com.finmate.data.local.database.entity.TransactionEntity;\r\n\r\nimport java.util.List;\r\n\r\n@Dao\r\npublic interface TransactionDao {\r\n\r\n    @Insert\r\n    void insert(TransactionEntity transaction);\r\n\r\n    // ✅ Thêm limit để tránh load quá nhiều dữ liệu\r\n    @Query(\"SELECT * FROM transactions ORDER BY id DESC LIMIT :limit\")\r\n    List<TransactionEntity> getAll(int limit);\r\n    \r\n    @Query(\"SELECT * FROM transactions ORDER BY id DESC\")\r\n    List<TransactionEntity> getAll();\r\n\r\n    @Query(\"SELECT * FROM transactions WHERE wallet = :walletName ORDER BY id DESC LIMIT :limit\")\r\n    List<TransactionEntity> getByWalletName(String walletName, int limit);\r\n    \r\n    @Query(\"SELECT * FROM transactions WHERE wallet = :walletName ORDER BY id DESC\")\r\n    List<TransactionEntity> getByWalletName(String walletName);\r\n\r\n    // ✅ Filter by date range với limit\r\n    @Query(\"SELECT * FROM transactions WHERE (:startDate IS NULL OR date >= :startDate) AND (:endDate IS NULL OR date <= :endDate) ORDER BY id DESC LIMIT :limit\")\r\n    List<TransactionEntity> getByDateRange(String startDate, String endDate, int limit);\r\n    \r\n    @Query(\"SELECT * FROM transactions WHERE (:startDate IS NULL OR date >= :startDate) AND (:endDate IS NULL OR date <= :endDate) ORDER BY id DESC\")\r\n    List<TransactionEntity> getByDateRange(String startDate, String endDate);\r\n\r\n    // ✅ Filter by wallet and date range với limit\r\n    @Query(\"SELECT * FROM transactions WHERE wallet = :walletName AND (:startDate IS NULL OR date >= :startDate) AND (:endDate IS NULL OR date <= :endDate) ORDER BY id DESC LIMIT :limit\")\r\n    List<TransactionEntity> getByWalletNameAndDateRange(String walletName, String startDate, String endDate, int limit);\r\n    \r\n    @Query(\"SELECT * FROM transactions WHERE wallet = :walletName AND (:startDate IS NULL OR date >= :startDate) AND (:endDate IS NULL OR date <= :endDate) ORDER BY id DESC\")\r\n    List<TransactionEntity> getByWalletNameAndDateRange(String walletName, String startDate, String endDate);\r\n    \r\n    // ✅ Query để lấy transactions chưa sync (không có remoteId) - tối ưu cho sync manager\r\n    @Query(\"SELECT * FROM transactions WHERE id NOT IN (:syncedIds) ORDER BY id DESC LIMIT :limit\")\r\n    List<TransactionEntity> getUnsyncedTransactions(List<Integer> syncedIds, int limit);\r\n\r\n    @Query(\"SELECT * FROM transactions WHERE id = :id\")\r\n    TransactionEntity getById(int id);\r\n\r\n    @Update\r\n    void update(TransactionEntity transaction);\r\n\r\n    @Delete\r\n    void delete(TransactionEntity transaction);\r\n\r\n    @Query(\"DELETE FROM transactions WHERE id = :id\")\r\n    void deleteById(int id);\r\n    \r\n    // ✅ Bulk delete để tối ưu memory\r\n    @Query(\"DELETE FROM transactions\")\r\n    void deleteAll();\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/finmate/data/local/database/dao/TransactionDao.java b/app/src/main/java/com/finmate/data/local/database/dao/TransactionDao.java
--- a/app/src/main/java/com/finmate/data/local/database/dao/TransactionDao.java	(revision 156bc616bb4c3d046268d7f0400bef81621c2927)
+++ b/app/src/main/java/com/finmate/data/local/database/dao/TransactionDao.java	(date 1765527288875)
@@ -29,18 +29,18 @@
     @Query("SELECT * FROM transactions WHERE wallet = :walletName ORDER BY id DESC")
     List<TransactionEntity> getByWalletName(String walletName);
 
-    // ✅ Filter by date range với limit
-    @Query("SELECT * FROM transactions WHERE (:startDate IS NULL OR date >= :startDate) AND (:endDate IS NULL OR date <= :endDate) ORDER BY id DESC LIMIT :limit")
+    // ✅ Filter by date range với limit - dùng SUBSTR để so sánh chỉ phần date (10 ký tự đầu)
+    @Query("SELECT * FROM transactions WHERE (:startDate IS NULL OR SUBSTR(date, 1, 10) >= :startDate) AND (:endDate IS NULL OR SUBSTR(date, 1, 10) <= :endDate) ORDER BY id DESC LIMIT :limit")
     List<TransactionEntity> getByDateRange(String startDate, String endDate, int limit);
     
-    @Query("SELECT * FROM transactions WHERE (:startDate IS NULL OR date >= :startDate) AND (:endDate IS NULL OR date <= :endDate) ORDER BY id DESC")
+    @Query("SELECT * FROM transactions WHERE (:startDate IS NULL OR SUBSTR(date, 1, 10) >= :startDate) AND (:endDate IS NULL OR SUBSTR(date, 1, 10) <= :endDate) ORDER BY id DESC")
     List<TransactionEntity> getByDateRange(String startDate, String endDate);
 
-    // ✅ Filter by wallet and date range với limit
-    @Query("SELECT * FROM transactions WHERE wallet = :walletName AND (:startDate IS NULL OR date >= :startDate) AND (:endDate IS NULL OR date <= :endDate) ORDER BY id DESC LIMIT :limit")
+    // ✅ Filter by wallet and date range với limit - dùng SUBSTR để so sánh chỉ phần date (10 ký tự đầu)
+    @Query("SELECT * FROM transactions WHERE wallet = :walletName AND (:startDate IS NULL OR SUBSTR(date, 1, 10) >= :startDate) AND (:endDate IS NULL OR SUBSTR(date, 1, 10) <= :endDate) ORDER BY id DESC LIMIT :limit")
     List<TransactionEntity> getByWalletNameAndDateRange(String walletName, String startDate, String endDate, int limit);
     
-    @Query("SELECT * FROM transactions WHERE wallet = :walletName AND (:startDate IS NULL OR date >= :startDate) AND (:endDate IS NULL OR date <= :endDate) ORDER BY id DESC")
+    @Query("SELECT * FROM transactions WHERE wallet = :walletName AND (:startDate IS NULL OR SUBSTR(date, 1, 10) >= :startDate) AND (:endDate IS NULL OR SUBSTR(date, 1, 10) <= :endDate) ORDER BY id DESC")
     List<TransactionEntity> getByWalletNameAndDateRange(String walletName, String startDate, String endDate);
     
     // ✅ Query để lấy transactions chưa sync (không có remoteId) - tối ưu cho sync manager
Index: app/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<resources>\r\n    <string name=\"app_name\">FinMate</string>\r\n\r\n    <!-- General -->\r\n    <string name=\"username_hint\">Tên người dùng</string>\r\n    <string name=\"password_hint\">Mật khẩu</string>\r\n    <string name=\"email_hint\">Email</string>\r\n    <string name=\"login\">Đăng nhập</string>\r\n    <string name=\"signup\">Đăng ký</string>\r\n    <string name=\"save_changes\">Lưu thay đổi</string>\r\n    <string name=\"name\">Tên</string>\r\n    <string name=\"email\">Email</string>\r\n    <string name=\"birthday\">Ngày sinh</string>\r\n    <string name=\"description\">Mô tả bản thân</string>\r\n    <string name=\"friends\">Bạn bè</string>\r\n    <string name=\"feature_in_development\">Tính năng đang phát triển</string>\r\n    <string name=\"connect\">Connect</string>\r\n    <string name=\"delete\">Xóa</string>\r\n    <string name=\"edit\">Chỉnh sửa</string>\r\n    <string name=\"confirm_delete_friend_title\">Xóa bạn bè</string>\r\n    <string name=\"confirm_delete_friend_message\">Bạn chắc chắn muốn xóa người bạn này khỏi danh sách connect?</string>\r\n\r\n    <!-- Login Screen -->\r\n    <string name=\"welcome_back\">Chào mừng quay trở lại !</string>\r\n    <string name=\"forgot_password\">Quên mật khẩu</string>\r\n    <string name=\"no_account\">Bạn không có tài khoản? Đăng ký</string>\r\n\r\n    <!-- Signup Screen -->\r\n    <string name=\"create_account\">Tạo tài khoản</string>\r\n    <string name=\"signup_button\">Đăng ký</string>\r\n    <string name=\"already_have_account\">Đã có tài khoản? Đăng nhập</string>\r\n\r\n    <!-- Home Screen -->\r\n    <string name=\"greeting\">Chào,</string>\r\n    <string name=\"chart_title\">Thống kê thu nhập - chi tiêu</string>\r\n\r\n    <!-- Add Transaction Screen -->\r\n    <string name=\"add_transaction\">Thêm giao dịch</string>\r\n    <string name=\"add_transaction_title\">Thêm giao dịch</string>\r\n    <string name=\"select_group_first\">Vui lòng chọn nhóm giao dịch trước!</string>\r\n    <string name=\"select_date\">Chọn ngày</string>\r\n    <string name=\"select_start_date\">Chọn ngày bắt đầu</string>\r\n    <string name=\"select_end_date\">Chọn ngày kết thúc</string>\r\n    <string name=\"due_date\">Đến hạn</string>\r\n    <string name=\"today\">Hôm nay</string>\r\n    <string name=\"yesterday\">Hôm qua</string>\r\n    <string name=\"single_day\">Một ngày</string>\r\n    <string name=\"date_range\">Khoảng ngày (từ → đến)</string>\r\n    <string name=\"clear\">Xóa ngày</string>\r\n    <string name=\"transaction_saved\">Đã lưu giao dịch!</string>\r\n    <string name=\"fill_all_info\">Vui lòng nhập đầy đủ thông tin!</string>\r\n    <string name=\"category_hint\">Phân loại</string>\r\n    <string name=\"title_hint\">Tiêu đề</string>\r\n    <string name=\"amount_hint\">Số tiền</string>\r\n    <string name=\"friend_hint\">Bạn bè</string>\r\n    <string name=\"note_hint\">Ghi chú</string>\r\n    <string name=\"select_due_date_title\">Chọn ngày đến hạn</string>\r\n\r\n    <!-- Account Screen -->\r\n    <string name=\"income\">Thu nhập</string>\r\n    <string name=\"expense\">Chi tiêu</string>\r\n    <string name=\"balance\">Số dư</string>\r\n    <string name=\"enter_name_hint\">Nhập tên</string>\r\n    <string name=\"enter_email_hint\">Nhập email</string>\r\n    <string name=\"enter_description_hint\">Nhập mô tả...</string>\r\n    <string name=\"toast_change_avatar\">Đổi avatar</string>\r\n    <string name=\"toast_edit_mode\">Chế độ chỉnh sửa</string>\r\n    <string name=\"toast_changes_saved\">Đã lưu thay đổi</string>\r\n\r\n    <!-- Wallet Screen -->\r\n    <string name=\"my_account\">Tài khoản của tôi</string>\r\n    <string name=\"my_wallet\">Ví của tôi</string>\r\n    <string name=\"personal\">Riêng tôi</string>\r\n\r\n    <!-- Statistic Screen -->\r\n    <string name=\"statistic_monthly_expense\">Thống kê chi tiêu theo tháng</string>\r\n    <string name=\"filter_by_category\">Theo thể loại</string>\r\n    <string name=\"compare_expense_types\">So sánh các loại chi tiêu</string>\r\n    <string name=\"statistic_monthly_income\">Thống kê thu nhập theo tháng</string>\r\n    <string name=\"compare_income_types\">So sánh các loại thu nhập</string>\r\n\r\n    <!-- Category Screens -->\r\n    <string name=\"select_transaction_group\">Chọn nhóm giao dịch</string>\r\n    <string name=\"select_income_group\">Chọn nhóm giao dịch thu nhập</string>\r\n    <string name=\"select_expense_group\">Chọn nhóm giao dịch chi tiêu</string>\r\n    <string name=\"add_new_category_group\">Thêm mới nhóm phân loại</string>\r\n\r\n    <!-- Friend Screen -->\r\n    <string name=\"active\">Đang hoạt động</string>\r\n    <string name=\"paused\">Tạm dừng hoạt động</string>\r\n    <string name=\"connect_new_friend\">Connect bạn mới</string>\r\n    <string name=\"email_or_friend_name\">Email/Tên bạn mới</string>\r\n    <string name=\"show_as_list\">Hiển thị dưới dạng danh sách</string>\r\n    <string name=\"show_as_grid\">Hiển thị dưới dạng lưới</string>\r\n    <string name=\"share\">Chia sẻ</string>\r\n    <string name=\"help_and_feedback\">Trợ giúp &amp; Phản hồi</string>\r\n\r\n    <!-- Settings Screen -->\r\n    <string name=\"manage_categories\">Quản lý thể loại</string>\r\n    <string name=\"system_theme_setting\">Giao diện hệ thống</string>\r\n    <string name=\"notifications\">Thông báo</string>\r\n\r\n    <!-- Bottom Navigation -->\r\n    <string name=\"nav_home\">Home</string>\r\n    <string name=\"nav_wallet\">Ví tiền</string>\r\n    <string name=\"nav_add\">Thêm</string>\r\n    <string name=\"nav_statistic\">Thống kê</string>\r\n    <string name=\"nav_settings\">Cài đặt</string>\r\n\r\n    <!-- Settings Options -->\r\n    <string name=\"language\">Ngôn ngữ</string>\r\n    <string name=\"theme\">Giao diện</string>\r\n    <string name=\"choose_language\">Chọn ngôn ngữ</string>\r\n    <string name=\"choose_theme\">Chọn giao diện</string>\r\n    <string name=\"light_theme\">Sáng</string>\r\n    <string name=\"dark_theme\">Tối</string>\r\n    <string name=\"system_theme\">Theo hệ thống</string>\r\n    <string name=\"cancel\">Hủy</string>\r\n    \r\n    <!-- Language -->\r\n    <string name=\"title_language\">Chọn ngôn ngữ</string>\r\n    <string name=\"language_vietnamese\">Tiếng Việt</string>\r\n    <string name=\"language_english\">English</string>\r\n\r\n    <!-- Logout -->\r\n    <string name=\"logout\">Đăng xuất</string>\r\n    <string name=\"logout_confirmation\">Bạn có chắc chắn muốn đăng xuất?</string>\r\n\r\n    <!-- Empty States -->\r\n    <string name=\"no_transactions\">Chưa có giao dịch nào</string>\r\n    <string name=\"no_transactions_hint\">Bấm + để thêm giao dịch mới</string>\r\n    <string name=\"no_wallets\">Chưa có ví nào</string>\r\n    <string name=\"no_wallets_hint\">Bấm + để thêm ví mới</string>\r\n    <string name=\"no_friends\">Chưa có bạn bè nào</string>\r\n    <string name=\"no_friends_hint\">Bấm Connect để thêm bạn bè</string>\r\n    <string name=\"no_statistics\">Chưa có dữ liệu thống kê</string>\r\n    <string name=\"no_statistics_hint\">Thêm giao dịch để xem thống kê</string>\r\n\r\n    <!-- Filter -->\r\n    <string name=\"all_wallets\">Tất cả ví</string>\r\n    <string name=\"this_month\">Tháng này</string>\r\n    <string name=\"this_year\">Năm này</string>\r\n    <string name=\"filter_time\">Lọc thời gian</string>\r\n    <string name=\"filter_wallet\">Lọc ví</string>\r\n    <string name=\"filter_transaction_type\">Lọc loại giao dịch</string>\r\n    <string name=\"all_transactions\">Tất cả</string>\r\n    <string name=\"income_only\">Chỉ thu nhập</string>\r\n    <string name=\"expense_only\">Chỉ chi tiêu</string>\r\n\r\n    <!-- Validation -->\r\n    <string name=\"required_field\">Trường này là bắt buộc</string>\r\n    <string name=\"invalid_email\">Email không hợp lệ</string>\r\n    <string name=\"password_too_short\">Mật khẩu phải có ít nhất 6 ký tự</string>\r\n    <string name=\"amount_invalid\">Số tiền không hợp lệ</string>\r\n\r\n    <!-- Sync -->\r\n    <string name=\"sync_now\">Đồng bộ ngay</string>\r\n    <string name=\"syncing\">Đang đồng bộ...</string>\r\n    <string name=\"sync_success\">Đồng bộ thành công</string>\r\n    <string name=\"sync_failed\">Đồng bộ thất bại</string>\r\n\r\n    <!-- Language -->\r\n    <string name=\"system_language\">Theo ngôn ngữ hệ thống</string>\r\n\r\n    <!-- Transaction -->\r\n    <string name=\"delete_transaction\">Xóa giao dịch</string>\r\n    <string name=\"confirm_delete_transaction\">Bạn có chắc chắn muốn xóa giao dịch này?</string>\r\n    <string name=\"edit_transaction\">Chỉnh sửa giao dịch</string>\r\n\r\n    <!-- Wallet -->\r\n    <string name=\"set_default_wallet\">Đặt làm ví mặc định</string>\r\n    <string name=\"default_wallet\">Ví mặc định</string>\r\n    <string name=\"wallet_type_cash\">Tiền mặt</string>\r\n    <string name=\"wallet_type_bank\">Ngân hàng</string>\r\n    <string name=\"wallet_type_ewallet\">Ví điện tử</string>\r\n    <string name=\"initial_balance\">Số dư ban đầu</string>\r\n    <string name=\"wallet_color\">Màu ví</string>\r\n\r\n    <!-- Home Screen Additional -->\r\n    <string name=\"user\">Người dùng</string>\r\n    <string name=\"select_wallet\">Chọn ví</string>\r\n    <string name=\"last_updated_at\">Cập nhật lúc %1$s</string>\r\n    <string name=\"income_label\">Thu nhập</string>\r\n    <string name=\"expense_label\">Chi tiêu</string>\r\n\r\n</resources>\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/values/strings.xml b/app/src/main/res/values/strings.xml
--- a/app/src/main/res/values/strings.xml	(revision 156bc616bb4c3d046268d7f0400bef81621c2927)
+++ b/app/src/main/res/values/strings.xml	(date 1765526559300)
@@ -183,5 +183,12 @@
     <string name="last_updated_at">Cập nhật lúc %1$s</string>
     <string name="income_label">Thu nhập</string>
     <string name="expense_label">Chi tiêu</string>
+    
+    <!-- Time Filter Options -->
+    <string name="time_filter_today">Hôm nay</string>
+    <string name="time_filter_7_days">7 ngày qua</string>
+    <string name="time_filter_1_month">1 tháng qua</string>
+    <string name="time_filter_6_months">6 tháng qua</string>
+    <string name="time_filter_all_time">Tất cả thời gian</string>
 
 </resources>
Index: build.gradle.kts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Top-level build file where you can add configuration options common to all sub-projects/modules.\r\nplugins {\r\n    // Chuyển AGP lên phiên bản 9.0.\r\n    id(\"com.android.application\") version \"8.13.2\" apply false\r\n    id(\"com.google.dagger.hilt.android\") version \"2.51.1\" apply false\r\n}\r\nval defaultTargetSdkVersion by extra(34)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/build.gradle.kts b/build.gradle.kts
--- a/build.gradle.kts	(revision 156bc616bb4c3d046268d7f0400bef81621c2927)
+++ b/build.gradle.kts	(date 1765516945391)
@@ -1,6 +1,5 @@
 // Top-level build file where you can add configuration options common to all sub-projects/modules.
 plugins {
-    // Chuyển AGP lên phiên bản 9.0.
     id("com.android.application") version "8.13.2" apply false
     id("com.google.dagger.hilt.android") version "2.51.1" apply false
 }
Index: app/src/main/java/com/finmate/ui/friend/FriendActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.finmate.ui.friend;\r\n\r\n\r\nimport android.content.Context;\r\nimport android.os.Bundle;\r\nimport android.widget.Button;\r\nimport android.widget.EditText;\r\nimport android.widget.Toast;\r\nimport com.finmate.R;\r\n\r\nimport androidx.appcompat.app.AppCompatActivity;\r\nimport androidx.lifecycle.ViewModelProvider;\r\nimport androidx.recyclerview.widget.LinearLayoutManager;\r\nimport androidx.recyclerview.widget.RecyclerView;\r\n\r\nimport com.finmate.core.ui.LocaleHelper;\r\n\r\nimport java.util.ArrayList;\r\n\r\nimport dagger.hilt.android.AndroidEntryPoint;\r\n\r\n@AndroidEntryPoint\r\npublic class FriendActivity extends AppCompatActivity {\r\n\r\n    @Override\r\n    protected void attachBaseContext(Context newBase) {\r\n        super.attachBaseContext(LocaleHelper.applyLocale(newBase));\r\n    }\r\n\r\n    private RecyclerView recyclerView;\r\n    private FriendAdapter adapter;\r\n\r\n    private EditText etEmail;\r\n    private Button btnAdd;\r\n\r\n    private FriendViewModel viewModel;\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_friend);\r\n\r\n        viewModel = new ViewModelProvider(this).get(FriendViewModel.class);\r\n\r\n        recyclerView = findViewById(R.id.rvFriends);\r\n        etEmail = findViewById(R.id.etEmail);\r\n        btnAdd = findViewById(R.id.btnFriend);\r\n\r\n        adapter = new FriendAdapter(new ArrayList<>());\r\n        recyclerView.setLayoutManager(new LinearLayoutManager(this));\r\n        recyclerView.setAdapter(adapter);\r\n\r\n        observeViewModel();\r\n        setupActions();\r\n\r\n        viewModel.loadFriends();\r\n    }\r\n\r\n    private void observeViewModel() {\r\n        viewModel.friends.observe(this, list -> {\r\n            adapter.updateData(list);  // anh thêm hàm này trong FriendAdapter\r\n        });\r\n\r\n        viewModel.loading.observe(this, isLoading -> {\r\n            // show/hide progress bar nếu anh có\r\n        });\r\n\r\n        viewModel.error.observe(this, msg -> {\r\n            if (msg != null && !msg.isEmpty()) {\r\n                Toast.makeText(this, msg, Toast.LENGTH_SHORT).show();\r\n            }\r\n        });\r\n    }\r\n\r\n    private void setupActions() {\r\n        btnAdd.setOnClickListener(v -> {\r\n            String email = etEmail.getText().toString().trim();\r\n            if (email.isEmpty()) {\r\n                Toast.makeText(this, \"Nhập email bạn bè\", Toast.LENGTH_SHORT).show();\r\n                return;\r\n            }\r\n            viewModel.sendRequest(email);\r\n        });\r\n\r\n        // nếu FriendAdapter có callback accept/reject/remove thì pass vào đây\r\n        adapter.setOnActionListener(new FriendAdapter.OnActionListener() {\r\n            @Override\r\n            public void onRemove(FriendUIModel item) {\r\n                viewModel.remove(item.getFriendshipId());\r\n            }\r\n\r\n            @Override\r\n            public void onAccept(FriendUIModel item) {\r\n                viewModel.accept(item.getFriendshipId());\r\n            }\r\n\r\n            @Override\r\n            public void onReject(FriendUIModel item) {\r\n                viewModel.reject(item.getFriendshipId());\r\n            }\r\n        });\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/finmate/ui/friend/FriendActivity.java b/app/src/main/java/com/finmate/ui/friend/FriendActivity.java
--- a/app/src/main/java/com/finmate/ui/friend/FriendActivity.java	(revision 156bc616bb4c3d046268d7f0400bef81621c2927)
+++ b/app/src/main/java/com/finmate/ui/friend/FriendActivity.java	(date 1765517506093)
@@ -1,10 +1,10 @@
 package com.finmate.ui.friend;
 
-
 import android.content.Context;
 import android.os.Bundle;
-import android.widget.Button;
-import android.widget.EditText;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.TextView;
 import android.widget.Toast;
 import com.finmate.R;
 
@@ -29,9 +29,9 @@
 
     private RecyclerView recyclerView;
     private FriendAdapter adapter;
-
-    private EditText etEmail;
-    private Button btnAdd;
+    private ImageView btnBack;
+    private ImageView btnMore;
+    private android.widget.Button btnConnectNewFriend;
 
     private FriendViewModel viewModel;
 
@@ -42,27 +42,78 @@
 
         viewModel = new ViewModelProvider(this).get(FriendViewModel.class);
 
+        initViews();
+        setupViews();
+        observeViewModel();
+        setupActions();
+
+        viewModel.loadFriends();
+    }
+
+    private void initViews() {
         recyclerView = findViewById(R.id.rvFriends);
-        etEmail = findViewById(R.id.etEmail);
-        btnAdd = findViewById(R.id.btnFriend);
+        btnBack = findViewById(R.id.btnBack);
+        btnMore = findViewById(R.id.btnMore);
+        btnConnectNewFriend = findViewById(R.id.btnConnectNewFriend);
 
         adapter = new FriendAdapter(new ArrayList<>());
         recyclerView.setLayoutManager(new LinearLayoutManager(this));
         recyclerView.setAdapter(adapter);
+    }
+
+    private void setupViews() {
+        // Back button
+        if (btnBack != null) {
+            btnBack.setOnClickListener(v -> finish());
+        }
 
-        observeViewModel();
-        setupActions();
+        // More button
+        if (btnMore != null) {
+            btnMore.setOnClickListener(v -> {
+                // TODO: Show menu options
+            });
+        }
 
-        viewModel.loadFriends();
+        // Connect New Friend Button
+        if (btnConnectNewFriend != null) {
+            btnConnectNewFriend.setOnClickListener(v -> showConnectFriendDialog());
+        }
+
+        // Setup empty state
+        View layoutEmptyState = findViewById(R.id.layoutEmptyState);
+        if (layoutEmptyState != null) {
+            TextView tvEmptyTitle = layoutEmptyState.findViewById(R.id.tvEmptyTitle);
+            TextView tvEmptyHint = layoutEmptyState.findViewById(R.id.tvEmptyHint);
+            if (tvEmptyTitle != null) {
+                tvEmptyTitle.setText(R.string.no_friends);
+            }
+            if (tvEmptyHint != null) {
+                tvEmptyHint.setText(R.string.no_friends_hint);
+            }
+        }
     }
 
     private void observeViewModel() {
         viewModel.friends.observe(this, list -> {
-            adapter.updateData(list);  // anh thêm hàm này trong FriendAdapter
+            if (adapter != null) {
+                adapter.updateData(list != null ? list : new ArrayList<>());
+            }
+
+            // Show/hide empty state based on data
+            View layoutEmptyState = findViewById(R.id.layoutEmptyState);
+            if (layoutEmptyState != null && recyclerView != null) {
+                if (list == null || list.isEmpty()) {
+                    layoutEmptyState.setVisibility(View.VISIBLE);
+                    recyclerView.setVisibility(View.GONE);
+                } else {
+                    layoutEmptyState.setVisibility(View.GONE);
+                    recyclerView.setVisibility(View.VISIBLE);
+                }
+            }
         });
 
         viewModel.loading.observe(this, isLoading -> {
-            // show/hide progress bar nếu anh có
+            // Show/hide progress indicator if needed
         });
 
         viewModel.error.observe(this, msg -> {
@@ -73,31 +124,47 @@
     }
 
     private void setupActions() {
-        btnAdd.setOnClickListener(v -> {
-            String email = etEmail.getText().toString().trim();
-            if (email.isEmpty()) {
-                Toast.makeText(this, "Nhập email bạn bè", Toast.LENGTH_SHORT).show();
-                return;
-            }
-            viewModel.sendRequest(email);
-        });
-
-        // nếu FriendAdapter có callback accept/reject/remove thì pass vào đây
-        adapter.setOnActionListener(new FriendAdapter.OnActionListener() {
-            @Override
-            public void onRemove(FriendUIModel item) {
-                viewModel.remove(item.getFriendshipId());
-            }
+        if (adapter != null) {
+            adapter.setOnActionListener(new FriendAdapter.OnActionListener() {
+                @Override
+                public void onRemove(FriendUIModel item) {
+                    viewModel.remove(item.getFriendshipId());
+                }
 
-            @Override
-            public void onAccept(FriendUIModel item) {
-                viewModel.accept(item.getFriendshipId());
-            }
+                @Override
+                public void onAccept(FriendUIModel item) {
+                    viewModel.accept(item.getFriendshipId());
+                }
 
-            @Override
-            public void onReject(FriendUIModel item) {
-                viewModel.reject(item.getFriendshipId());
-            }
-        });
+                @Override
+                public void onReject(FriendUIModel item) {
+                    viewModel.reject(item.getFriendshipId());
+                }
+            });
+        }
     }
+
+    private void showConnectFriendDialog() {
+        android.app.AlertDialog.Builder builder = new android.app.AlertDialog.Builder(this);
+        builder.setTitle(R.string.connect_new_friend);
+        
+        // Create input field
+        final android.widget.EditText input = new android.widget.EditText(this);
+        input.setHint(R.string.email_or_friend_name);
+        input.setInputType(android.text.InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS);
+        builder.setView(input);
+        
+        builder.setPositiveButton(R.string.connect, (dialog, which) -> {
+            String emailOrName = input.getText().toString().trim();
+            if (emailOrName.isEmpty()) {
+                Toast.makeText(this, R.string.fill_all_info, Toast.LENGTH_SHORT).show();
+                return;
+            }
+            // Call API to send friend request via ViewModel
+            viewModel.sendRequest(emailOrName);
+        });
+        
+        builder.setNegativeButton(R.string.cancel, null);
+        builder.show();
+    }
 }
Index: app/src/main/java/com/finmate/data/repository/TransactionRepository.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.finmate.data.repository;\r\n\r\nimport android.content.Context;\r\n\r\nimport com.finmate.data.local.database.AppDatabase;\r\nimport com.finmate.data.local.database.dao.TransactionDao;\r\nimport com.finmate.data.local.database.entity.TransactionEntity;\r\n\r\nimport java.util.List;\r\nimport java.util.concurrent.Executor;\r\nimport java.util.concurrent.Executors;\r\n\r\nimport javax.inject.Inject;\r\nimport javax.inject.Singleton;\r\n\r\nimport dagger.hilt.android.qualifiers.ApplicationContext;\r\n\r\n@Singleton\r\npublic class TransactionRepository {\r\n\r\n    private static final Executor EXECUTOR = Executors.newSingleThreadExecutor();\r\n\r\n    private final TransactionDao dao;\r\n\r\n    @Inject\r\n    public TransactionRepository(@ApplicationContext Context context) {\r\n        dao = AppDatabase.getDatabase(context).transactionDao();\r\n    }\r\n\r\n    public void insert(TransactionEntity entity) {\r\n        EXECUTOR.execute(() -> dao.insert(entity));\r\n    }\r\n\r\n    // ✅ Default limit cho UI (500 items đủ cho hầu hết trường hợp)\r\n    private static final int DEFAULT_LIMIT = 500;\r\n    \r\n    public void getAll(OnResultCallback<List<TransactionEntity>> callback) {\r\n        getAll(DEFAULT_LIMIT, callback);\r\n    }\r\n    \r\n    public void getAll(int limit, OnResultCallback<List<TransactionEntity>> callback) {\r\n        EXECUTOR.execute(() -> callback.onResult(dao.getAll(limit)));\r\n    }\r\n\r\n    public void getByWalletName(String walletName, OnResultCallback<List<TransactionEntity>> callback) {\r\n        getByWalletName(walletName, DEFAULT_LIMIT, callback);\r\n    }\r\n    \r\n    public void getByWalletName(String walletName, int limit, OnResultCallback<List<TransactionEntity>> callback) {\r\n        EXECUTOR.execute(() -> callback.onResult(dao.getByWalletName(walletName, limit)));\r\n    }\r\n\r\n    // ✅ Filter by date range - dùng SQL thay vì filter in memory\r\n    public void getByDateRange(Long startDate, Long endDate, OnResultCallback<List<TransactionEntity>> callback) {\r\n        getByDateRange(startDate, endDate, DEFAULT_LIMIT, callback);\r\n    }\r\n    \r\n    public void getByDateRange(Long startDate, Long endDate, int limit, OnResultCallback<List<TransactionEntity>> callback) {\r\n        EXECUTOR.execute(() -> {\r\n            String startDateStr = startDate != null ? formatDateForQuery(startDate) : null;\r\n            String endDateStr = endDate != null ? formatDateForQuery(endDate) : null;\r\n            // ✅ Dùng SQL query thay vì load tất cả rồi filter\r\n            callback.onResult(dao.getByDateRange(startDateStr, endDateStr, limit));\r\n        });\r\n    }\r\n\r\n    // ✅ Filter by wallet and date range - dùng SQL thay vì filter in memory\r\n    public void getByWalletNameAndDateRange(String walletName, Long startDate, Long endDate, OnResultCallback<List<TransactionEntity>> callback) {\r\n        getByWalletNameAndDateRange(walletName, startDate, endDate, DEFAULT_LIMIT, callback);\r\n    }\r\n    \r\n    public void getByWalletNameAndDateRange(String walletName, Long startDate, Long endDate, int limit, OnResultCallback<List<TransactionEntity>> callback) {\r\n        EXECUTOR.execute(() -> {\r\n            String startDateStr = startDate != null ? formatDateForQuery(startDate) : null;\r\n            String endDateStr = endDate != null ? formatDateForQuery(endDate) : null;\r\n            // ✅ Dùng SQL query thay vì load tất cả rồi filter\r\n            callback.onResult(dao.getByWalletNameAndDateRange(walletName, startDateStr, endDateStr, limit));\r\n        });\r\n    }\r\n    \r\n    // ✅ Method tối ưu cho sync manager - chỉ lấy transactions chưa sync\r\n    public void getUnsyncedTransactions(List<Integer> syncedIds, int limit, OnResultCallback<List<TransactionEntity>> callback) {\r\n        EXECUTOR.execute(() -> {\r\n            if (syncedIds == null || syncedIds.isEmpty()) {\r\n                // Nếu không có synced IDs, lấy tất cả (giới hạn)\r\n                callback.onResult(dao.getAll(limit));\r\n            } else {\r\n                callback.onResult(dao.getUnsyncedTransactions(syncedIds, limit));\r\n            }\r\n        });\r\n    }\r\n\r\n    // ✅ Convert timestamp (milliseconds) to ISO date string for comparison\r\n    private String formatDateForQuery(Long timestamp) {\r\n        java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat(\"yyyy-MM-dd\", java.util.Locale.getDefault());\r\n        return sdf.format(new java.util.Date(timestamp));\r\n    }\r\n\r\n    public void update(TransactionEntity entity) {\r\n        EXECUTOR.execute(() -> dao.update(entity));\r\n    }\r\n\r\n    public void delete(TransactionEntity entity) {\r\n        EXECUTOR.execute(() -> dao.delete(entity));\r\n    }\r\n\r\n    /**\r\n     * Ghi đè toàn bộ transaction local = data mới từ server.\r\n     * ✅ Tối ưu: Không load tất cả existing vào memory, dùng bulk delete\r\n     */\r\n    public void replaceAll(List<TransactionEntity> transactions) {\r\n        EXECUTOR.execute(() -> {\r\n            // ✅ Xóa tất cả bằng SQL query thay vì load vào memory\r\n            dao.deleteAll();\r\n            // ✅ Insert batch\r\n            for (TransactionEntity t : transactions) {\r\n                dao.insert(t);\r\n            }\r\n        });\r\n    }\r\n\r\n    public interface OnResultCallback<T> {\r\n        void onResult(T data);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/finmate/data/repository/TransactionRepository.java b/app/src/main/java/com/finmate/data/repository/TransactionRepository.java
--- a/app/src/main/java/com/finmate/data/repository/TransactionRepository.java	(revision 156bc616bb4c3d046268d7f0400bef81621c2927)
+++ b/app/src/main/java/com/finmate/data/repository/TransactionRepository.java	(date 1765524959411)
@@ -35,57 +35,116 @@
     private static final int DEFAULT_LIMIT = 500;
     
     public void getAll(OnResultCallback<List<TransactionEntity>> callback) {
+        if (callback == null) return;
         getAll(DEFAULT_LIMIT, callback);
     }
     
     public void getAll(int limit, OnResultCallback<List<TransactionEntity>> callback) {
-        EXECUTOR.execute(() -> callback.onResult(dao.getAll(limit)));
+        if (callback == null) return;
+        EXECUTOR.execute(() -> {
+            try {
+                List<TransactionEntity> result = dao.getAll(limit);
+                android.util.Log.d("TransactionRepository", "getAll: loaded " + (result != null ? result.size() : 0) + " transactions");
+                callback.onResult(result);
+            } catch (Exception e) {
+                android.util.Log.e("TransactionRepository", "Error in getAll: " + e.getMessage(), e);
+                // Handle database errors gracefully
+                callback.onResult(null);
+            }
+        });
     }
 
     public void getByWalletName(String walletName, OnResultCallback<List<TransactionEntity>> callback) {
+        if (callback == null) return;
         getByWalletName(walletName, DEFAULT_LIMIT, callback);
     }
     
     public void getByWalletName(String walletName, int limit, OnResultCallback<List<TransactionEntity>> callback) {
-        EXECUTOR.execute(() -> callback.onResult(dao.getByWalletName(walletName, limit)));
+        if (callback == null) return;
+        EXECUTOR.execute(() -> {
+            try {
+                callback.onResult(dao.getByWalletName(walletName, limit));
+            } catch (Exception e) {
+                callback.onResult(null);
+            }
+        });
     }
 
     // ✅ Filter by date range - dùng SQL thay vì filter in memory
     public void getByDateRange(Long startDate, Long endDate, OnResultCallback<List<TransactionEntity>> callback) {
+        if (callback == null) return;
         getByDateRange(startDate, endDate, DEFAULT_LIMIT, callback);
     }
     
     public void getByDateRange(Long startDate, Long endDate, int limit, OnResultCallback<List<TransactionEntity>> callback) {
+        if (callback == null) return;
         EXECUTOR.execute(() -> {
-            String startDateStr = startDate != null ? formatDateForQuery(startDate) : null;
-            String endDateStr = endDate != null ? formatDateForQuery(endDate) : null;
-            // ✅ Dùng SQL query thay vì load tất cả rồi filter
-            callback.onResult(dao.getByDateRange(startDateStr, endDateStr, limit));
+            try {
+                // ✅ Nếu cả startDate và endDate đều null → load tất cả
+                if (startDate == null && endDate == null) {
+                    List<TransactionEntity> result = dao.getAll(limit);
+                    android.util.Log.d("TransactionRepository", "getByDateRange(null, null): loaded " + (result != null ? result.size() : 0) + " transactions");
+                    callback.onResult(result);
+                    return;
+                }
+                
+                String startDateStr = startDate != null ? formatDateForQuery(startDate) : null;
+                String endDateStr = endDate != null ? formatDateForQuery(endDate) : null;
+                // ✅ Dùng SQL query thay vì load tất cả rồi filter
+                List<TransactionEntity> result = dao.getByDateRange(startDateStr, endDateStr, limit);
+                android.util.Log.d("TransactionRepository", "getByDateRange(" + startDateStr + ", " + endDateStr + "): loaded " + (result != null ? result.size() : 0) + " transactions");
+                callback.onResult(result);
+            } catch (Exception e) {
+                android.util.Log.e("TransactionRepository", "Error in getByDateRange: " + e.getMessage(), e);
+                callback.onResult(null);
+            }
         });
     }
 
     // ✅ Filter by wallet and date range - dùng SQL thay vì filter in memory
     public void getByWalletNameAndDateRange(String walletName, Long startDate, Long endDate, OnResultCallback<List<TransactionEntity>> callback) {
+        if (callback == null) return;
         getByWalletNameAndDateRange(walletName, startDate, endDate, DEFAULT_LIMIT, callback);
     }
     
     public void getByWalletNameAndDateRange(String walletName, Long startDate, Long endDate, int limit, OnResultCallback<List<TransactionEntity>> callback) {
+        if (callback == null) return;
         EXECUTOR.execute(() -> {
-            String startDateStr = startDate != null ? formatDateForQuery(startDate) : null;
-            String endDateStr = endDate != null ? formatDateForQuery(endDate) : null;
-            // ✅ Dùng SQL query thay vì load tất cả rồi filter
-            callback.onResult(dao.getByWalletNameAndDateRange(walletName, startDateStr, endDateStr, limit));
+            try {
+                // ✅ Nếu cả startDate và endDate đều null → chỉ filter theo wallet
+                if (startDate == null && endDate == null) {
+                    List<TransactionEntity> result = dao.getByWalletName(walletName, limit);
+                    android.util.Log.d("TransactionRepository", "getByWalletNameAndDateRange(" + walletName + ", null, null): loaded " + (result != null ? result.size() : 0) + " transactions");
+                    callback.onResult(result);
+                    return;
+                }
+                
+                String startDateStr = startDate != null ? formatDateForQuery(startDate) : null;
+                String endDateStr = endDate != null ? formatDateForQuery(endDate) : null;
+                // ✅ Dùng SQL query thay vì load tất cả rồi filter
+                List<TransactionEntity> result = dao.getByWalletNameAndDateRange(walletName, startDateStr, endDateStr, limit);
+                android.util.Log.d("TransactionRepository", "getByWalletNameAndDateRange(" + walletName + ", " + startDateStr + ", " + endDateStr + "): loaded " + (result != null ? result.size() : 0) + " transactions");
+                callback.onResult(result);
+            } catch (Exception e) {
+                android.util.Log.e("TransactionRepository", "Error in getByWalletNameAndDateRange: " + e.getMessage(), e);
+                callback.onResult(null);
+            }
         });
     }
     
     // ✅ Method tối ưu cho sync manager - chỉ lấy transactions chưa sync
     public void getUnsyncedTransactions(List<Integer> syncedIds, int limit, OnResultCallback<List<TransactionEntity>> callback) {
+        if (callback == null) return;
         EXECUTOR.execute(() -> {
-            if (syncedIds == null || syncedIds.isEmpty()) {
-                // Nếu không có synced IDs, lấy tất cả (giới hạn)
-                callback.onResult(dao.getAll(limit));
-            } else {
-                callback.onResult(dao.getUnsyncedTransactions(syncedIds, limit));
+            try {
+                if (syncedIds == null || syncedIds.isEmpty()) {
+                    // Nếu không có synced IDs, lấy tất cả (giới hạn)
+                    callback.onResult(dao.getAll(limit));
+                } else {
+                    callback.onResult(dao.getUnsyncedTransactions(syncedIds, limit));
+                }
+            } catch (Exception e) {
+                callback.onResult(null);
             }
         });
     }
@@ -104,6 +163,17 @@
         EXECUTOR.execute(() -> dao.delete(entity));
     }
 
+    public void getById(int id, OnResultCallback<TransactionEntity> callback) {
+        if (callback == null) return;
+        EXECUTOR.execute(() -> {
+            try {
+                callback.onResult(dao.getById(id));
+            } catch (Exception e) {
+                callback.onResult(null);
+            }
+        });
+    }
+
     /**
      * Ghi đè toàn bộ transaction local = data mới từ server.
      * ✅ Tối ưu: Không load tất cả existing vào memory, dùng bulk delete
Index: app/src/main/java/com/finmate/data/repository/CategoryRepository.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.finmate.data.repository;\r\n\r\nimport android.content.Context;\r\nimport androidx.lifecycle.LiveData;\r\n\r\nimport com.finmate.core.network.ApiCallback;\r\nimport com.finmate.core.network.NetworkChecker;\r\nimport com.finmate.data.dto.CategoryRequest;\r\nimport com.finmate.data.dto.CategoryResponse;\r\nimport com.finmate.data.local.database.AppDatabase;\r\nimport com.finmate.data.local.database.dao.CategoryDao;\r\nimport com.finmate.data.local.database.entity.CategoryEntity;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.concurrent.Executor;\r\nimport java.util.concurrent.Executors;\r\n\r\nimport javax.inject.Inject;\r\nimport javax.inject.Singleton;\r\n\r\nimport dagger.hilt.android.qualifiers.ApplicationContext;\r\n\r\n@Singleton\r\npublic class CategoryRepository {\r\n\r\n    private static final Executor EXECUTOR = Executors.newSingleThreadExecutor();\r\n\r\n    private final CategoryDao dao;\r\n    private final CategoryRemoteRepository remoteRepo;\r\n    private final Context context;\r\n    private final NetworkChecker networkChecker;\r\n\r\n    @Inject\r\n    public CategoryRepository(@ApplicationContext Context ctx,\r\n                              CategoryRemoteRepository remoteRepo,\r\n                              NetworkChecker networkChecker) {\r\n        this.context = ctx;\r\n        this.dao = AppDatabase.getDatabase(ctx).categoryDao();\r\n        this.remoteRepo = remoteRepo;\r\n        this.networkChecker = networkChecker;\r\n    }\r\n\r\n    // ===== LOCAL CRUD =====\r\n\r\n    public void insert(CategoryEntity e) {\r\n        EXECUTOR.execute(() -> dao.insert(e));\r\n    }\r\n\r\n    public void update(CategoryEntity e) {\r\n        EXECUTOR.execute(() -> dao.update(e));\r\n    }\r\n\r\n    public void delete(CategoryEntity e) {\r\n        EXECUTOR.execute(() -> dao.delete(e));\r\n    }\r\n\r\n    // Sửa lại: Trả về LiveData để ViewModel có thể observe sự thay đổi dữ liệu một cách an toàn\r\n    public LiveData<List<CategoryEntity>> getByType(String type) {\r\n        return dao.getByType(type);\r\n    }\r\n\r\n    public LiveData<List<CategoryEntity>> getAll() {\r\n        return dao.getAll();\r\n    }\r\n\r\n    // ✅ Lấy category theo name (async)\r\n    public void getByName(String name, OnResultCallback<CategoryEntity> callback) {\r\n        EXECUTOR.execute(() -> callback.onResult(dao.getByName(name)));\r\n    }\r\n\r\n    public interface OnResultCallback<T> {\r\n        void onResult(T result);\r\n    }\r\n\r\n    // Sửa lại: Dùng transaction để đảm bảo tính toàn vẹn khi thay thế dữ liệu.\r\n    private void replaceByType(String type, List<CategoryEntity> list) {\r\n        EXECUTOR.execute(() -> {\r\n            AppDatabase.getDatabase(context).runInTransaction(() -> {\r\n                dao.deleteByType(type);\r\n                for (CategoryEntity entity : list) {\r\n                    dao.insert(entity);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    // ===== REMOTE OPERATIONS =====\r\n\r\n    // Offline-first: Chỉ sync từ server nếu có mạng\r\n    // ViewModel sẽ nhận dữ liệu mới thông qua LiveData từ getByType (đã load local trước).\r\n    public void fetchRemoteCategoriesByType(String type) {\r\n        // Chỉ gọi BE nếu có mạng\r\n        if (!networkChecker.isNetworkAvailable()) {\r\n            // Không có mạng → chỉ dùng data local (đã load qua LiveData)\r\n            return;\r\n        }\r\n\r\n        remoteRepo.fetchCategoriesByType(type, new ApiCallback<List<CategoryResponse>>() {\r\n            @Override\r\n            public void onSuccess(List<CategoryResponse> body) {\r\n                if (body == null) return;\r\n\r\n                List<CategoryEntity> mapped = new ArrayList<>();\r\n                for (CategoryResponse r : body) {\r\n                    // Lưu icon name (String) trực tiếp từ server\r\n                    mapped.add(new CategoryEntity(\r\n                            r.getName(),\r\n                            r.getType(),\r\n                            r.getIcon() != null ? r.getIcon() : \"\"\r\n                    ));\r\n                }\r\n                replaceByType(type, mapped);\r\n            }\r\n\r\n            @Override\r\n            public void onError(String msg) {\r\n                // Có thể log lỗi hoặc hiển thị thông báo cho người dùng nếu cần\r\n            }\r\n        });\r\n    }\r\n\r\n    public void createCategory(CategoryEntity localDraft, OperationCallback cb) {\r\n        // Chỉ sync lên BE nếu có mạng\r\n        if (!networkChecker.isNetworkAvailable()) {\r\n            // Không có mạng → lưu local trước (offline-first)\r\n            insert(localDraft);\r\n            cb.onSuccess();\r\n            return;\r\n        }\r\n\r\n        // Có mạng → gọi BE trước, sau đó lưu local với dữ liệu từ server\r\n        CategoryRequest req = new CategoryRequest(\r\n                localDraft.getName(),\r\n                localDraft.getType(),\r\n                localDraft.getIcon() != null ? localDraft.getIcon() : \"\"\r\n        );\r\n\r\n        remoteRepo.createCategory(req, new ApiCallback<CategoryResponse>() {\r\n            @Override\r\n            public void onSuccess(CategoryResponse res) {\r\n                // Lưu local với dữ liệu từ server\r\n                CategoryEntity e = new CategoryEntity(\r\n                        res.getName(),\r\n                        res.getType(),\r\n                        res.getIcon() != null ? res.getIcon() : \"\"\r\n                );\r\n                insert(e);\r\n                cb.onSuccess();\r\n            }\r\n\r\n            @Override\r\n            public void onError(String msg) {\r\n                cb.onError(msg);\r\n            }\r\n        });\r\n    }\r\n\r\n    public void updateCategory(CategoryEntity edit, OperationCallback cb) {\r\n        // Update local trước (offline-first)\r\n        update(edit);\r\n        \r\n        // Chỉ sync lên BE nếu có mạng\r\n        if (!networkChecker.isNetworkAvailable()) {\r\n            // Không có mạng → đã update local, callback success\r\n            cb.onSuccess();\r\n            return;\r\n        }\r\n\r\n        String id = String.valueOf(edit.getId());\r\n        // Sử dụng icon name (String) trực tiếp từ CategoryEntity\r\n        CategoryRequest req = new CategoryRequest(\r\n                edit.getName(),\r\n                edit.getType(),\r\n                edit.getIcon() != null ? edit.getIcon() : \"\"\r\n        );\r\n\r\n        remoteRepo.updateCategory(id, req, new ApiCallback<CategoryResponse>() {\r\n            @Override\r\n            public void onSuccess(CategoryResponse res) {\r\n                CategoryEntity updated = new CategoryEntity(\r\n                        res.getName(),\r\n                        res.getType(),\r\n                        res.getIcon() != null ? res.getIcon() : \"\"\r\n                );\r\n                updated.setId(edit.getId());\r\n                update(updated);\r\n                cb.onSuccess();\r\n            }\r\n\r\n            @Override\r\n            public void onError(String msg) {\r\n                cb.onError(msg);\r\n            }\r\n        });\r\n    }\r\n\r\n    public void deleteCategory(CategoryEntity e, OperationCallback cb) {\r\n        // Xóa local trước (offline-first)\r\n        delete(e);\r\n        \r\n        // Chỉ sync lên BE nếu có mạng\r\n        if (!networkChecker.isNetworkAvailable()) {\r\n            // Không có mạng → đã xóa local, callback success\r\n            cb.onSuccess();\r\n            return;\r\n        }\r\n\r\n        String id = String.valueOf(e.getId());\r\n\r\n        remoteRepo.deleteCategory(id, new ApiCallback<Void>() {\r\n            @Override\r\n            public void onSuccess(Void unused) {\r\n                // Đã xóa local ở trên, chỉ cần callback success\r\n                cb.onSuccess();\r\n            }\r\n\r\n            @Override\r\n            public void onError(String msg) {\r\n                cb.onError(msg);\r\n            }\r\n        });\r\n    }\r\n\r\n    // ===== CALLBACK INTERFACE =====\r\n    public interface OperationCallback {\r\n        void onSuccess();\r\n        void onError(String msg);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/finmate/data/repository/CategoryRepository.java b/app/src/main/java/com/finmate/data/repository/CategoryRepository.java
--- a/app/src/main/java/com/finmate/data/repository/CategoryRepository.java	(revision 156bc616bb4c3d046268d7f0400bef81621c2927)
+++ b/app/src/main/java/com/finmate/data/repository/CategoryRepository.java	(date 1765517286485)
@@ -66,7 +66,14 @@
 
     // ✅ Lấy category theo name (async)
     public void getByName(String name, OnResultCallback<CategoryEntity> callback) {
-        EXECUTOR.execute(() -> callback.onResult(dao.getByName(name)));
+        if (callback == null) return;
+        EXECUTOR.execute(() -> {
+            try {
+                callback.onResult(dao.getByName(name));
+            } catch (Exception e) {
+                callback.onResult(null);
+            }
+        });
     }
 
     public interface OnResultCallback<T> {
Index: app/src/main/java/com/finmate/data/repository/HomeRepository.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.finmate.data.repository;\r\n\r\nimport com.finmate.core.network.ApiCallback;\r\nimport com.finmate.core.network.NetworkChecker;\r\nimport com.finmate.data.dto.TransactionPageResponse;\r\nimport com.finmate.data.dto.TransactionResponse;\r\nimport com.finmate.data.dto.WalletResponse;\r\nimport com.finmate.data.local.database.entity.TransactionEntity;\r\nimport com.finmate.data.local.database.entity.WalletEntity;\r\n\r\nimport java.util.List;\r\n\r\nimport javax.inject.Inject;\r\nimport javax.inject.Singleton;\r\n\r\n@Singleton\r\npublic class HomeRepository {\r\n\r\n    private final WalletRemoteRepository walletRemoteRepository;\r\n    private final WalletRepository walletLocalRepository;\r\n    private final TransactionRemoteRepository transactionRemoteRepository;\r\n    private final TransactionRepository transactionLocalRepository;\r\n    private final CategoryRepository categoryRepository; // ✅ Thêm để map categoryId -> categoryName\r\n    private final NetworkChecker networkChecker;\r\n\r\n    @Inject\r\n    public HomeRepository(WalletRemoteRepository walletRemoteRepository, \r\n                         WalletRepository walletLocalRepository, \r\n                         TransactionRemoteRepository transactionRemoteRepository, \r\n                         TransactionRepository transactionLocalRepository,\r\n                         CategoryRepository categoryRepository,\r\n                         NetworkChecker networkChecker) {\r\n        this.walletRemoteRepository = walletRemoteRepository;\r\n        this.walletLocalRepository = walletLocalRepository;\r\n        this.transactionRemoteRepository = transactionRemoteRepository;\r\n        this.transactionLocalRepository = transactionLocalRepository;\r\n        this.categoryRepository = categoryRepository;\r\n        this.networkChecker = networkChecker;\r\n    }\r\n\r\n    public interface DataCallback<T> {\r\n        void onDataLoaded(T data);\r\n        void onError(String message);\r\n    }\r\n\r\n    // Offline-first: Đọc local trước, chỉ sync khi có mạng\r\n    public void fetchWallets(DataCallback<List<WalletEntity>> callback) {\r\n        // 1) Luôn load local trước để UI có gì đó hiển thị (offline vẫn chạy được)\r\n        walletLocalRepository.getAll(new WalletRepository.Callback() {\r\n            @Override\r\n            public void onResult(List<WalletEntity> list) {\r\n                callback.onDataLoaded(list);\r\n            }\r\n        });\r\n\r\n        // 2) Chỉ gọi BE nếu có mạng để sync dữ liệu mới nhất về local\r\n        if (!networkChecker.isNetworkAvailable()) {\r\n            // Không có mạng → chỉ dùng data local đã load ở bước 1\r\n            return;\r\n        }\r\n\r\n        walletRemoteRepository.fetchMyWallets(new ApiCallback<List<WalletResponse>>() {\r\n            @Override\r\n            public void onSuccess(List<WalletResponse> body) {\r\n                // Map WalletResponse -> WalletEntity\r\n                // ✅ Backend đã filter deleted=false, nên chỉ lưu wallets chưa bị xóa\r\n                List<WalletEntity> mapped = new java.util.ArrayList<>();\r\n                if (body != null) {\r\n                    for (WalletResponse w : body) {\r\n                        // ✅ Chỉ lưu wallets chưa bị xóa (backend đã filter, nhưng double-check để an toàn)\r\n                        if (w.isDeleted()) {\r\n                            continue; // Bỏ qua wallets đã bị xóa\r\n                        }\r\n                        \r\n                        // ✅ Nếu backend chưa trả về currentBalance, dùng initialBalance làm fallback\r\n                        double currentBalance = w.getCurrentBalance() != 0.0 ? w.getCurrentBalance() : w.getInitialBalance();\r\n                        double initialBalance = w.getInitialBalance();\r\n                        \r\n                        String formattedBalance = String.format(\r\n                                \"%,.0f %s\",\r\n                                currentBalance, // ✅ Dùng currentBalance (hoặc initialBalance nếu chưa có)\r\n                                w.getCurrency() != null ? w.getCurrency() : \"\"\r\n                        );\r\n\r\n                        WalletEntity entity = new WalletEntity(\r\n                                w.getId(), // ✅ Lưu ID từ backend (UUID)\r\n                                w.getName(),\r\n                                formattedBalance,\r\n                                currentBalance, // ✅ Lưu currentBalance\r\n                                initialBalance, // ✅ Lưu initialBalance\r\n                                0 // iconRes tạm thời = 0, sau này anh map theo type\r\n                        );\r\n                        mapped.add(entity);\r\n                    }\r\n                }\r\n\r\n                // 2.1) Ghi đè vào local cache\r\n                walletLocalRepository.replaceAll(mapped);\r\n\r\n                // 2.2) Đẩy list mới lên UI\r\n                callback.onDataLoaded(mapped);\r\n            }\r\n\r\n            @Override\r\n            public void onError(String message) {\r\n                // BE lỗi (mất mạng, 401 refresh fail, server down...)\r\n                // -> cứ để UI dùng data local đã load ở bước 1\r\n                // optional: callback.onError(message);\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n\r\n    public void fetchTransactions(String walletId, String walletName, Long startDate, Long endDate, DataCallback<List<TransactionEntity>> callback) {\r\n        // ✅ walletName được truyền từ HomeActivity (từ wallets đã có, không cần query DB)\r\n        final String finalWalletName = walletName;\r\n        final Long finalStartDate = startDate;\r\n        final Long finalEndDate = endDate;\r\n\r\n        // 1) Luôn load local trước → offline vẫn xem được\r\n        if (finalWalletName != null) {\r\n            // ✅ Filter theo walletName và time\r\n            transactionLocalRepository.getByWalletNameAndDateRange(finalWalletName, finalStartDate, finalEndDate, new TransactionRepository.OnResultCallback<List<TransactionEntity>>() {\r\n                @Override\r\n                public void onResult(List<TransactionEntity> data) {\r\n                    callback.onDataLoaded(data);\r\n                }\r\n            });\r\n        } else {\r\n            // ✅ Tất cả ví, filter theo time\r\n            transactionLocalRepository.getByDateRange(finalStartDate, finalEndDate, new TransactionRepository.OnResultCallback<List<TransactionEntity>>() {\r\n                @Override\r\n                public void onResult(List<TransactionEntity> data) {\r\n                    callback.onDataLoaded(data);\r\n                }\r\n            });\r\n        }\r\n\r\n        // 2) Chỉ gọi BE nếu có mạng để sync dữ liệu mới nhất về local\r\n        if (!networkChecker.isNetworkAvailable()) {\r\n            // Không có mạng → chỉ dùng data local đã load ở bước 1\r\n            return;\r\n        }\r\n\r\n        // ✅ Chỉ sync từ backend khi chọn \"Tất cả ví\" (walletId == null)\r\n        // Khi chọn ví cụ thể, chỉ filter ở local để không mất transactions của ví khác\r\n        if (walletId != null) {\r\n            // Chọn ví cụ thể → chỉ dùng data local đã filter ở bước 1, không sync từ backend\r\n            return;\r\n        }\r\n\r\n        // ✅ Chỉ khi chọn \"Tất cả ví\" mới sync từ backend\r\n        transactionRemoteRepository.fetchTransactions(null, new ApiCallback<TransactionPageResponse>() {\r\n            @Override\r\n            public void onSuccess(TransactionPageResponse page) {\r\n                if (page == null || page.getContent() == null) {\r\n                    return;\r\n                }\r\n\r\n                // ✅ Lấy danh sách wallets và categories để map\r\n                walletLocalRepository.getAll(new WalletRepository.Callback() {\r\n                    @Override\r\n                    public void onResult(List<WalletEntity> wallets) {\r\n                        List<TransactionEntity> mapped = new java.util.ArrayList<>();\r\n                        for (TransactionResponse t : page.getContent()) {\r\n                            // ✅ Tìm walletName từ walletId\r\n                            String walletNameForTransaction = null;\r\n                            if (t.getWalletId() != null && wallets != null) {\r\n                                for (WalletEntity w : wallets) {\r\n                                    if (w.id.equals(t.getWalletId())) {\r\n                                        walletNameForTransaction = w.name;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            // ✅ Backend đã trả về categoryName trong TransactionResponse\r\n                            String categoryName = t.getCategoryName() != null ? t.getCategoryName() : \"\";\r\n\r\n                                // Format số tiền + thời gian → map vào TransactionEntity hiện tại\r\n                                double amountValue = t.getAmount() != null ? t.getAmount().doubleValue() : 0.0;\r\n                                String amountFormatted = String.format(\r\n                                        \"%,.0f\",\r\n                                        amountValue\r\n                                );\r\n\r\n                                // ✅ Format occurredAt từ Instant (backend) hoặc String\r\n                                String dateDisplay = \"\";\r\n                                if (t.getOccurredAt() != null) {\r\n                                    dateDisplay = t.getOccurredAt(); // Gson sẽ parse Instant thành String ISO format\r\n                                }\r\n\r\n                                // Ở HomeRepository cũ anh đang dùng ctor:\r\n                                // new TransactionEntity(title, category, amountText, walletName, dateText)\r\n                                String title = (t.getNote() != null && !t.getNote().isEmpty())\r\n                                        ? t.getNote()\r\n                                        : (categoryName.isEmpty() ? \"\" : categoryName);\r\n\r\n                                // ✅ Lưu type và amountDouble để tính toán\r\n                                TransactionEntity entity = new TransactionEntity(\r\n                                        title,\r\n                                        categoryName, // ✅ Dùng category name thực tế, không dùng \"Unknown\"\r\n                                        amountFormatted,\r\n                                        walletNameForTransaction != null ? walletNameForTransaction : \"\",\r\n                                        dateDisplay,\r\n                                        t.getType(), // ✅ Lưu type từ backend\r\n                                        amountValue  // ✅ Lưu amount (double) để tính toán\r\n                                );\r\n\r\n                                mapped.add(entity);\r\n                            }\r\n\r\n                            // 2.1) Ghi đè vào local cache (chỉ khi sync tất cả ví)\r\n                            transactionLocalRepository.replaceAll(mapped);\r\n\r\n                            // 2.2) Đẩy list mới lên UI (filter theo walletName nếu cần)\r\n                            if (finalWalletName != null) {\r\n                                // Filter lại theo walletName\r\n                                List<TransactionEntity> filtered = new java.util.ArrayList<>();\r\n                                for (TransactionEntity e : mapped) {\r\n                                    if (e.wallet != null && e.wallet.equals(finalWalletName)) {\r\n                                        filtered.add(e);\r\n                                    }\r\n                                }\r\n                                callback.onDataLoaded(filtered);\r\n                            } else {\r\n                                callback.onDataLoaded(mapped);\r\n                            }\r\n                        }\r\n                    });\r\n            }\r\n\r\n            @Override\r\n            public void onError(String message) {\r\n                // BE lỗi (mất mạng, refresh fail, server down...)\r\n                // → cứ để UI dùng data local đã load ở bước 1\r\n                // optional: callback.onError(message);\r\n            }\r\n        });\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/finmate/data/repository/HomeRepository.java b/app/src/main/java/com/finmate/data/repository/HomeRepository.java
--- a/app/src/main/java/com/finmate/data/repository/HomeRepository.java	(revision 156bc616bb4c3d046268d7f0400bef81621c2927)
+++ b/app/src/main/java/com/finmate/data/repository/HomeRepository.java	(date 1765527707114)
@@ -119,12 +119,16 @@
         final Long finalEndDate = endDate;
 
         // 1) Luôn load local trước → offline vẫn xem được
+        android.util.Log.d("HomeRepository", "fetchTransactions: walletId=" + walletId + ", walletName=" + finalWalletName + ", startDate=" + finalStartDate + ", endDate=" + finalEndDate);
         if (finalWalletName != null) {
             // ✅ Filter theo walletName và time
             transactionLocalRepository.getByWalletNameAndDateRange(finalWalletName, finalStartDate, finalEndDate, new TransactionRepository.OnResultCallback<List<TransactionEntity>>() {
                 @Override
                 public void onResult(List<TransactionEntity> data) {
-                    callback.onDataLoaded(data);
+                    android.util.Log.d("HomeRepository", "getByWalletNameAndDateRange result: " + (data != null ? data.size() : 0) + " transactions");
+                    if (callback != null) {
+                        callback.onDataLoaded(data != null ? data : new java.util.ArrayList<>());
+                    }
                 }
             });
         } else {
@@ -132,7 +136,10 @@
             transactionLocalRepository.getByDateRange(finalStartDate, finalEndDate, new TransactionRepository.OnResultCallback<List<TransactionEntity>>() {
                 @Override
                 public void onResult(List<TransactionEntity> data) {
-                    callback.onDataLoaded(data);
+                    android.util.Log.d("HomeRepository", "getByDateRange result: " + (data != null ? data.size() : 0) + " transactions");
+                    if (callback != null) {
+                        callback.onDataLoaded(data != null ? data : new java.util.ArrayList<>());
+                    }
                 }
             });
         }
Index: app/src/main/java/com/finmate/ui/auth/SignUpActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.finmate.ui.auth;\r\n\r\nimport android.content.Context;\r\nimport android.content.Intent;\r\nimport android.os.Bundle;\r\nimport android.widget.Button;\r\nimport android.widget.EditText;\r\nimport android.widget.TextView;\r\nimport android.widget.Toast;\r\n\r\nimport androidx.appcompat.app.AppCompatActivity;\r\nimport androidx.lifecycle.ViewModelProvider;\r\n\r\nimport com.finmate.R;\r\nimport com.finmate.core.ui.LocaleHelper;\r\nimport com.finmate.ui.home.HomeActivity;\r\n\r\nimport dagger.hilt.android.AndroidEntryPoint;\r\n\r\n@AndroidEntryPoint\r\npublic class SignUpActivity extends AppCompatActivity {\r\n\r\n    @Override\r\n    protected void attachBaseContext(Context newBase) {\r\n        super.attachBaseContext(LocaleHelper.applyLocale(newBase));\r\n    }\r\n\r\n    EditText etName, etEmail, etPassword;\r\n    Button btnSignup;\r\n    TextView tvAlreadyAccount;\r\n    \r\n    private SignUpViewModel signUpViewModel;\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_signup);\r\n        \r\n        signUpViewModel = new ViewModelProvider(this).get(SignUpViewModel.class);\r\n\r\n        // Ánh xạ thành phần giao diện\r\n        etName = findViewById(R.id.etName);\r\n        etEmail = findViewById(R.id.etEmail);\r\n        etPassword = findViewById(R.id.etPassword);\r\n        btnSignup = findViewById(R.id.btnSignup);\r\n        tvAlreadyAccount = findViewById(R.id.tvAlreadyAccount);\r\n        \r\n        observeViewModel();\r\n\r\n        // Xử lý nút SIGNUP\r\n        btnSignup.setOnClickListener(view -> {\r\n\r\n            String name = etName.getText().toString().trim();\r\n            String email = etEmail.getText().toString().trim();\r\n            String pass = etPassword.getText().toString().trim();\r\n\r\n            // VALIDATE\r\n            if (!validateInputs(name, email, pass)) {\r\n                return;\r\n            }\r\n            \r\n            String fullName = etName.getText().toString().trim();\r\n            String defaultAvatarUrl = \"ic_avatar\"; // Default avatar resource name\r\n            signUpViewModel.register(email, pass, fullName, defaultAvatarUrl);\r\n        });\r\n\r\n        // Quay lại Login\r\n        tvAlreadyAccount.setOnClickListener(view -> {\r\n            Intent intent = new Intent(SignUpActivity.this, LoginActivity.class);\r\n            startActivity(intent);\r\n            overridePendingTransition(android.R.anim.slide_in_left, android.R.anim.slide_out_right);\r\n            finish();\r\n        });\r\n    }\r\n    \r\n    private boolean validateInputs(String name, String email, String password) {\r\n        boolean isValid = true;\r\n        \r\n        // Validate name\r\n        if (name.isEmpty()) {\r\n            etName.setError(getString(R.string.required_field));\r\n            isValid = false;\r\n        } else {\r\n            etName.setError(null);\r\n        }\r\n        \r\n        // Validate email\r\n        if (email.isEmpty()) {\r\n            etEmail.setError(getString(R.string.required_field));\r\n            isValid = false;\r\n        } else if (!android.util.Patterns.EMAIL_ADDRESS.matcher(email).matches()) {\r\n            etEmail.setError(getString(R.string.invalid_email));\r\n            isValid = false;\r\n        } else {\r\n            etEmail.setError(null);\r\n        }\r\n        \r\n        // Validate password\r\n        if (password.isEmpty()) {\r\n            etPassword.setError(getString(R.string.required_field));\r\n            isValid = false;\r\n        } else if (password.length() < 6) {\r\n            etPassword.setError(getString(R.string.password_too_short));\r\n            isValid = false;\r\n        } else {\r\n            etPassword.setError(null);\r\n        }\r\n        \r\n        if (!isValid) {\r\n            Toast.makeText(this, R.string.fill_all_info, Toast.LENGTH_SHORT).show();\r\n        }\r\n        \r\n        return isValid;\r\n    }\r\n    \r\n    private void observeViewModel() {\r\n        signUpViewModel.isLoading.observe(this, isLoading -> {\r\n            btnSignup.setEnabled(!isLoading);\r\n            btnSignup.setText(isLoading ? getString(R.string.syncing) : getString(R.string.signup_button));\r\n            // Show progress indicator\r\n            if (isLoading) {\r\n                // TODO: Show progress bar/dialog if needed\r\n            }\r\n        });\r\n        \r\n        signUpViewModel.registerSuccess.observe(this, success -> {\r\n            if (success) {\r\n                Toast.makeText(SignUpActivity.this, \"Đăng ký thành công!\", Toast.LENGTH_SHORT).show();\r\n                Intent intent = new Intent(SignUpActivity.this, HomeActivity.class);\r\n                startActivity(intent);\r\n                overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);\r\n                finish();\r\n            }\r\n        });\r\n        \r\n        signUpViewModel.errorMessage.observe(this, error -> {\r\n            if (error != null && !error.isEmpty()) {\r\n                Toast.makeText(SignUpActivity.this, error, Toast.LENGTH_SHORT).show();\r\n            }\r\n        });\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/finmate/ui/auth/SignUpActivity.java b/app/src/main/java/com/finmate/ui/auth/SignUpActivity.java
--- a/app/src/main/java/com/finmate/ui/auth/SignUpActivity.java	(revision 156bc616bb4c3d046268d7f0400bef81621c2927)
+++ b/app/src/main/java/com/finmate/ui/auth/SignUpActivity.java	(date 1765516945392)
@@ -113,13 +113,26 @@
         return isValid;
     }
     
+    private android.app.ProgressDialog progressDialog;
+
     private void observeViewModel() {
         signUpViewModel.isLoading.observe(this, isLoading -> {
             btnSignup.setEnabled(!isLoading);
             btnSignup.setText(isLoading ? getString(R.string.syncing) : getString(R.string.signup_button));
             // Show progress indicator
             if (isLoading) {
-                // TODO: Show progress bar/dialog if needed
+                if (progressDialog == null) {
+                    progressDialog = new android.app.ProgressDialog(this);
+                    progressDialog.setMessage(getString(R.string.syncing));
+                    progressDialog.setCancelable(false);
+                }
+                if (!progressDialog.isShowing()) {
+                    progressDialog.show();
+                }
+            } else {
+                if (progressDialog != null && progressDialog.isShowing()) {
+                    progressDialog.dismiss();
+                }
             }
         });
         
Index: app/src/main/res/layout/bottom_sheet_time_filter.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"wrap_content\"\r\n    android:orientation=\"vertical\"\r\n    android:padding=\"16dp\"\r\n    android:background=\"?attr/cardBackgroundColor\">\r\n\r\n    <!-- Header -->\r\n    <TextView\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:text=\"@string/filter_time\"\r\n        android:textColor=\"?attr/textColorPrimary\"\r\n        android:textSize=\"20sp\"\r\n        android:textStyle=\"bold\"\r\n        android:paddingBottom=\"16dp\" />\r\n\r\n    <!-- Today -->\r\n    <LinearLayout\r\n        android:id=\"@+id/btnToday\"\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"56dp\"\r\n        android:orientation=\"horizontal\"\r\n        android:gravity=\"center_vertical\"\r\n        android:background=\"?attr/selectableItemBackground\"\r\n        android:paddingHorizontal=\"16dp\"\r\n        android:layout_marginBottom=\"8dp\">\r\n\r\n        <TextView\r\n            android:layout_width=\"0dp\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:layout_weight=\"1\"\r\n            android:text=\"@string/today\"\r\n            android:textColor=\"?attr/textColorPrimary\"\r\n            android:textSize=\"16sp\" />\r\n\r\n        <ImageView\r\n            android:id=\"@+id/ivTodayCheck\"\r\n            android:layout_width=\"24dp\"\r\n            android:layout_height=\"24dp\"\r\n            android:src=\"@drawable/ic_check\"\r\n            android:visibility=\"gone\"\r\n            app:tint=\"?attr/colorPrimary\" />\r\n    </LinearLayout>\r\n\r\n    <!-- Single Day -->\r\n    <LinearLayout\r\n        android:id=\"@+id/btnSingleDay\"\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"56dp\"\r\n        android:orientation=\"horizontal\"\r\n        android:gravity=\"center_vertical\"\r\n        android:background=\"?attr/selectableItemBackground\"\r\n        android:paddingHorizontal=\"16dp\"\r\n        android:layout_marginBottom=\"8dp\">\r\n\r\n        <TextView\r\n            android:layout_width=\"0dp\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:layout_weight=\"1\"\r\n            android:text=\"@string/single_day\"\r\n            android:textColor=\"?attr/textColorPrimary\"\r\n            android:textSize=\"16sp\" />\r\n\r\n        <TextView\r\n            android:id=\"@+id/tvSingleDayDate\"\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:text=\"\"\r\n            android:textColor=\"?attr/textColorSecondary\"\r\n            android:textSize=\"14sp\"\r\n            android:layout_marginEnd=\"8dp\" />\r\n\r\n        <ImageView\r\n            android:id=\"@+id/ivSingleDayCheck\"\r\n            android:layout_width=\"24dp\"\r\n            android:layout_height=\"24dp\"\r\n            android:src=\"@drawable/ic_check\"\r\n            android:visibility=\"gone\"\r\n            app:tint=\"?attr/colorPrimary\" />\r\n    </LinearLayout>\r\n\r\n    <!-- Date Range -->\r\n    <LinearLayout\r\n        android:id=\"@+id/btnDateRange\"\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:orientation=\"vertical\"\r\n        android:background=\"?attr/selectableItemBackground\"\r\n        android:paddingHorizontal=\"16dp\"\r\n        android:paddingVertical=\"12dp\"\r\n        android:layout_marginBottom=\"8dp\">\r\n\r\n        <LinearLayout\r\n            android:layout_width=\"match_parent\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:orientation=\"horizontal\"\r\n            android:gravity=\"center_vertical\">\r\n\r\n            <TextView\r\n                android:layout_width=\"0dp\"\r\n                android:layout_height=\"wrap_content\"\r\n                android:layout_weight=\"1\"\r\n                android:text=\"@string/date_range\"\r\n                android:textColor=\"?attr/textColorPrimary\"\r\n                android:textSize=\"16sp\" />\r\n\r\n            <ImageView\r\n                android:id=\"@+id/ivDateRangeCheck\"\r\n                android:layout_width=\"24dp\"\r\n                android:layout_height=\"24dp\"\r\n                android:src=\"@drawable/ic_check\"\r\n                android:visibility=\"gone\"\r\n                app:tint=\"?attr/colorPrimary\" />\r\n        </LinearLayout>\r\n\r\n        <LinearLayout\r\n            android:layout_width=\"match_parent\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:orientation=\"horizontal\"\r\n            android:layout_marginTop=\"8dp\">\r\n\r\n            <TextView\r\n                android:id=\"@+id/tvStartDate\"\r\n                android:layout_width=\"0dp\"\r\n                android:layout_height=\"wrap_content\"\r\n                android:layout_weight=\"1\"\r\n                android:text=\"@string/select_start_date\"\r\n                android:textColor=\"?attr/textColorSecondary\"\r\n                android:textSize=\"14sp\"\r\n                android:padding=\"8dp\"\r\n                android:background=\"?attr/selectableItemBackgroundBorderless\" />\r\n\r\n            <TextView\r\n                android:layout_width=\"wrap_content\"\r\n                android:layout_height=\"wrap_content\"\r\n                android:text=\"→\"\r\n                android:textColor=\"?attr/textColorSecondary\"\r\n                android:textSize=\"16sp\"\r\n                android:paddingHorizontal=\"8dp\" />\r\n\r\n            <TextView\r\n                android:id=\"@+id/tvEndDate\"\r\n                android:layout_width=\"0dp\"\r\n                android:layout_height=\"wrap_content\"\r\n                android:layout_weight=\"1\"\r\n                android:text=\"@string/select_end_date\"\r\n                android:textColor=\"?attr/textColorSecondary\"\r\n                android:textSize=\"14sp\"\r\n                android:padding=\"8dp\"\r\n                android:background=\"?attr/selectableItemBackgroundBorderless\" />\r\n        </LinearLayout>\r\n    </LinearLayout>\r\n\r\n    <!-- Clear -->\r\n    <LinearLayout\r\n        android:id=\"@+id/btnClear\"\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"56dp\"\r\n        android:orientation=\"horizontal\"\r\n        android:gravity=\"center_vertical\"\r\n        android:background=\"?attr/selectableItemBackground\"\r\n        android:paddingHorizontal=\"16dp\">\r\n\r\n        <TextView\r\n            android:layout_width=\"match_parent\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:text=\"@string/clear\"\r\n            android:textColor=\"?attr/colorError\"\r\n            android:textSize=\"16sp\"\r\n            android:gravity=\"center\" />\r\n    </LinearLayout>\r\n\r\n</LinearLayout>\r\n\r\n\r\n\r\n
===================================================================
diff --git a/app/src/main/res/layout/bottom_sheet_time_filter.xml b/app/src/main/res/layout/bottom_sheet_time_filter.xml
--- a/app/src/main/res/layout/bottom_sheet_time_filter.xml	(revision 156bc616bb4c3d046268d7f0400bef81621c2927)
+++ b/app/src/main/res/layout/bottom_sheet_time_filter.xml	(date 1765526559300)
@@ -45,6 +45,118 @@
             app:tint="?attr/colorPrimary" />
     </LinearLayout>
 
+    <!-- 7 Days Ago -->
+    <LinearLayout
+        android:id="@+id/btn7DaysAgo"
+        android:layout_width="match_parent"
+        android:layout_height="56dp"
+        android:orientation="horizontal"
+        android:gravity="center_vertical"
+        android:background="?attr/selectableItemBackground"
+        android:paddingHorizontal="16dp"
+        android:layout_marginBottom="8dp">
+
+        <TextView
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:text="@string/time_filter_7_days"
+            android:textColor="?attr/textColorPrimary"
+            android:textSize="16sp" />
+
+        <ImageView
+            android:id="@+id/iv7DaysCheck"
+            android:layout_width="24dp"
+            android:layout_height="24dp"
+            android:src="@drawable/ic_check"
+            android:visibility="gone"
+            app:tint="?attr/colorPrimary" />
+    </LinearLayout>
+
+    <!-- 1 Month Ago -->
+    <LinearLayout
+        android:id="@+id/btn1MonthAgo"
+        android:layout_width="match_parent"
+        android:layout_height="56dp"
+        android:orientation="horizontal"
+        android:gravity="center_vertical"
+        android:background="?attr/selectableItemBackground"
+        android:paddingHorizontal="16dp"
+        android:layout_marginBottom="8dp">
+
+        <TextView
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:text="@string/time_filter_1_month"
+            android:textColor="?attr/textColorPrimary"
+            android:textSize="16sp" />
+
+        <ImageView
+            android:id="@+id/iv1MonthCheck"
+            android:layout_width="24dp"
+            android:layout_height="24dp"
+            android:src="@drawable/ic_check"
+            android:visibility="gone"
+            app:tint="?attr/colorPrimary" />
+    </LinearLayout>
+
+    <!-- 6 Months Ago -->
+    <LinearLayout
+        android:id="@+id/btn6MonthsAgo"
+        android:layout_width="match_parent"
+        android:layout_height="56dp"
+        android:orientation="horizontal"
+        android:gravity="center_vertical"
+        android:background="?attr/selectableItemBackground"
+        android:paddingHorizontal="16dp"
+        android:layout_marginBottom="8dp">
+
+        <TextView
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:text="@string/time_filter_6_months"
+            android:textColor="?attr/textColorPrimary"
+            android:textSize="16sp" />
+
+        <ImageView
+            android:id="@+id/iv6MonthsCheck"
+            android:layout_width="24dp"
+            android:layout_height="24dp"
+            android:src="@drawable/ic_check"
+            android:visibility="gone"
+            app:tint="?attr/colorPrimary" />
+    </LinearLayout>
+
+    <!-- All Time -->
+    <LinearLayout
+        android:id="@+id/btnAllTime"
+        android:layout_width="match_parent"
+        android:layout_height="56dp"
+        android:orientation="horizontal"
+        android:gravity="center_vertical"
+        android:background="?attr/selectableItemBackground"
+        android:paddingHorizontal="16dp"
+        android:layout_marginBottom="8dp">
+
+        <TextView
+            android:layout_width="0dp"
+            android:layout_height="wrap_content"
+            android:layout_weight="1"
+            android:text="@string/time_filter_all_time"
+            android:textColor="?attr/textColorPrimary"
+            android:textSize="16sp" />
+
+        <ImageView
+            android:id="@+id/ivAllTimeCheck"
+            android:layout_width="24dp"
+            android:layout_height="24dp"
+            android:src="@drawable/ic_check"
+            android:visibility="gone"
+            app:tint="?attr/colorPrimary" />
+    </LinearLayout>
+
     <!-- Single Day -->
     <LinearLayout
         android:id="@+id/btnSingleDay"
Index: app/src/main/java/com/finmate/ui/dialogs/TimeFilterBottomSheet.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.finmate.ui.dialogs;\r\n\r\nimport android.app.DatePickerDialog;\r\nimport android.os.Bundle;\r\nimport android.view.LayoutInflater;\r\nimport android.view.View;\r\nimport android.view.ViewGroup;\r\nimport android.widget.ImageView;\r\nimport android.widget.LinearLayout;\r\nimport android.widget.TextView;\r\n\r\nimport androidx.annotation.NonNull;\r\nimport androidx.annotation.Nullable;\r\n\r\nimport com.finmate.R;\r\nimport com.google.android.material.bottomsheet.BottomSheetDialogFragment;\r\n\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Calendar;\r\nimport java.util.Date;\r\nimport java.util.Locale;\r\n\r\npublic class TimeFilterBottomSheet extends BottomSheetDialogFragment {\r\n\r\n    public interface TimeFilterListener {\r\n        void onTodaySelected();\r\n        void onSingleDaySelected(Date date);\r\n        void onDateRangeSelected(Date startDate, Date endDate);\r\n        void onClear();\r\n    }\r\n\r\n    private TimeFilterListener listener;\r\n    private Date selectedSingleDay;\r\n    private Date selectedStartDate;\r\n    private Date selectedEndDate;\r\n    private String currentFilterType = \"none\"; // \"today\", \"single\", \"range\", \"none\"\r\n\r\n    private ImageView ivTodayCheck, ivSingleDayCheck, ivDateRangeCheck;\r\n    private TextView tvSingleDayDate, tvStartDate, tvEndDate;\r\n\r\n    public static TimeFilterBottomSheet newInstance() {\r\n        return new TimeFilterBottomSheet();\r\n    }\r\n\r\n    public void setListener(TimeFilterListener listener) {\r\n        this.listener = listener;\r\n    }\r\n\r\n    @Nullable\r\n    @Override\r\n    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\r\n        return inflater.inflate(R.layout.bottom_sheet_time_filter, container, false);\r\n    }\r\n\r\n    @Override\r\n    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\r\n        super.onViewCreated(view, savedInstanceState);\r\n\r\n        ivTodayCheck = view.findViewById(R.id.ivTodayCheck);\r\n        ivSingleDayCheck = view.findViewById(R.id.ivSingleDayCheck);\r\n        ivDateRangeCheck = view.findViewById(R.id.ivDateRangeCheck);\r\n        tvSingleDayDate = view.findViewById(R.id.tvSingleDayDate);\r\n        tvStartDate = view.findViewById(R.id.tvStartDate);\r\n        tvEndDate = view.findViewById(R.id.tvEndDate);\r\n\r\n        LinearLayout btnToday = view.findViewById(R.id.btnToday);\r\n        LinearLayout btnSingleDay = view.findViewById(R.id.btnSingleDay);\r\n        LinearLayout btnDateRange = view.findViewById(R.id.btnDateRange);\r\n        LinearLayout btnClear = view.findViewById(R.id.btnClear);\r\n\r\n        btnToday.setOnClickListener(v -> {\r\n            currentFilterType = \"today\";\r\n            updateCheckIcons();\r\n            if (listener != null) {\r\n                listener.onTodaySelected();\r\n            }\r\n            dismiss();\r\n        });\r\n\r\n        btnSingleDay.setOnClickListener(v -> showSingleDayPicker());\r\n\r\n        tvSingleDayDate.setOnClickListener(v -> showSingleDayPicker());\r\n\r\n        btnDateRange.setOnClickListener(v -> {\r\n            currentFilterType = \"range\";\r\n            updateCheckIcons();\r\n        });\r\n\r\n        tvStartDate.setOnClickListener(v -> showStartDatePicker());\r\n        tvEndDate.setOnClickListener(v -> showEndDatePicker());\r\n\r\n        btnClear.setOnClickListener(v -> {\r\n            currentFilterType = \"none\";\r\n            selectedSingleDay = null;\r\n            selectedStartDate = null;\r\n            selectedEndDate = null;\r\n            updateCheckIcons();\r\n            updateDateTexts();\r\n            if (listener != null) {\r\n                listener.onClear();\r\n            }\r\n            dismiss();\r\n        });\r\n\r\n        updateCheckIcons();\r\n        updateDateTexts();\r\n    }\r\n\r\n    private void showSingleDayPicker() {\r\n        Calendar calendar = Calendar.getInstance();\r\n        if (selectedSingleDay != null) {\r\n            calendar.setTime(selectedSingleDay);\r\n        }\r\n\r\n        DatePickerDialog dialog = new DatePickerDialog(\r\n                requireContext(),\r\n                (view, year, month, dayOfMonth) -> {\r\n                    Calendar cal = Calendar.getInstance();\r\n                    cal.set(year, month, dayOfMonth);\r\n                    selectedSingleDay = cal.getTime();\r\n                    currentFilterType = \"single\";\r\n                    updateCheckIcons();\r\n                    updateDateTexts();\r\n                    if (listener != null) {\r\n                        listener.onSingleDaySelected(selectedSingleDay);\r\n                    }\r\n                    dismiss();\r\n                },\r\n                calendar.get(Calendar.YEAR),\r\n                calendar.get(Calendar.MONTH),\r\n                calendar.get(Calendar.DAY_OF_MONTH)\r\n        );\r\n        dialog.show();\r\n    }\r\n\r\n    private void showStartDatePicker() {\r\n        Calendar calendar = Calendar.getInstance();\r\n        if (selectedStartDate != null) {\r\n            calendar.setTime(selectedStartDate);\r\n        }\r\n\r\n        DatePickerDialog dialog = new DatePickerDialog(\r\n                requireContext(),\r\n                (view, year, month, dayOfMonth) -> {\r\n                    Calendar cal = Calendar.getInstance();\r\n                    cal.set(year, month, dayOfMonth);\r\n                    selectedStartDate = cal.getTime();\r\n                    updateDateTexts();\r\n                    if (selectedStartDate != null && selectedEndDate != null) {\r\n                        if (listener != null) {\r\n                            listener.onDateRangeSelected(selectedStartDate, selectedEndDate);\r\n                        }\r\n                        dismiss();\r\n                    }\r\n                },\r\n                calendar.get(Calendar.YEAR),\r\n                calendar.get(Calendar.MONTH),\r\n                calendar.get(Calendar.DAY_OF_MONTH)\r\n        );\r\n        dialog.show();\r\n    }\r\n\r\n    private void showEndDatePicker() {\r\n        Calendar calendar = Calendar.getInstance();\r\n        if (selectedEndDate != null) {\r\n            calendar.setTime(selectedEndDate);\r\n        }\r\n\r\n        DatePickerDialog dialog = new DatePickerDialog(\r\n                requireContext(),\r\n                (view, year, month, dayOfMonth) -> {\r\n                    Calendar cal = Calendar.getInstance();\r\n                    cal.set(year, month, dayOfMonth);\r\n                    selectedEndDate = cal.getTime();\r\n                    updateDateTexts();\r\n                    if (selectedStartDate != null && selectedEndDate != null) {\r\n                        if (listener != null) {\r\n                            listener.onDateRangeSelected(selectedStartDate, selectedEndDate);\r\n                        }\r\n                        dismiss();\r\n                    }\r\n                },\r\n                calendar.get(Calendar.YEAR),\r\n                calendar.get(Calendar.MONTH),\r\n                calendar.get(Calendar.DAY_OF_MONTH)\r\n        );\r\n        dialog.show();\r\n    }\r\n\r\n    private void updateCheckIcons() {\r\n        ivTodayCheck.setVisibility(\"today\".equals(currentFilterType) ? View.VISIBLE : View.GONE);\r\n        ivSingleDayCheck.setVisibility(\"single\".equals(currentFilterType) ? View.VISIBLE : View.GONE);\r\n        ivDateRangeCheck.setVisibility(\"range\".equals(currentFilterType) ? View.VISIBLE : View.GONE);\r\n    }\r\n\r\n    private void updateDateTexts() {\r\n        SimpleDateFormat sdf = new SimpleDateFormat(\"dd/MM/yyyy\", Locale.getDefault());\r\n\r\n        if (selectedSingleDay != null) {\r\n            tvSingleDayDate.setText(sdf.format(selectedSingleDay));\r\n        } else {\r\n            tvSingleDayDate.setText(\"\");\r\n        }\r\n\r\n        if (selectedStartDate != null) {\r\n            tvStartDate.setText(sdf.format(selectedStartDate));\r\n        } else {\r\n            tvStartDate.setText(getString(R.string.select_start_date));\r\n        }\r\n\r\n        if (selectedEndDate != null) {\r\n            tvEndDate.setText(sdf.format(selectedEndDate));\r\n        } else {\r\n            tvEndDate.setText(getString(R.string.select_end_date));\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n
===================================================================
diff --git a/app/src/main/java/com/finmate/ui/dialogs/TimeFilterBottomSheet.java b/app/src/main/java/com/finmate/ui/dialogs/TimeFilterBottomSheet.java
--- a/app/src/main/java/com/finmate/ui/dialogs/TimeFilterBottomSheet.java	(revision 156bc616bb4c3d046268d7f0400bef81621c2927)
+++ b/app/src/main/java/com/finmate/ui/dialogs/TimeFilterBottomSheet.java	(date 1765526559317)
@@ -24,6 +24,10 @@
 
     public interface TimeFilterListener {
         void onTodaySelected();
+        void on7DaysAgoSelected();
+        void on1MonthAgoSelected();
+        void on6MonthsAgoSelected();
+        void onAllTimeSelected();
         void onSingleDaySelected(Date date);
         void onDateRangeSelected(Date startDate, Date endDate);
         void onClear();
@@ -35,7 +39,7 @@
     private Date selectedEndDate;
     private String currentFilterType = "none"; // "today", "single", "range", "none"
 
-    private ImageView ivTodayCheck, ivSingleDayCheck, ivDateRangeCheck;
+    private ImageView ivTodayCheck, iv7DaysCheck, iv1MonthCheck, iv6MonthsCheck, ivAllTimeCheck, ivSingleDayCheck, ivDateRangeCheck;
     private TextView tvSingleDayDate, tvStartDate, tvEndDate;
 
     public static TimeFilterBottomSheet newInstance() {
@@ -57,6 +61,10 @@
         super.onViewCreated(view, savedInstanceState);
 
         ivTodayCheck = view.findViewById(R.id.ivTodayCheck);
+        iv7DaysCheck = view.findViewById(R.id.iv7DaysCheck);
+        iv1MonthCheck = view.findViewById(R.id.iv1MonthCheck);
+        iv6MonthsCheck = view.findViewById(R.id.iv6MonthsCheck);
+        ivAllTimeCheck = view.findViewById(R.id.ivAllTimeCheck);
         ivSingleDayCheck = view.findViewById(R.id.ivSingleDayCheck);
         ivDateRangeCheck = view.findViewById(R.id.ivDateRangeCheck);
         tvSingleDayDate = view.findViewById(R.id.tvSingleDayDate);
@@ -64,6 +72,10 @@
         tvEndDate = view.findViewById(R.id.tvEndDate);
 
         LinearLayout btnToday = view.findViewById(R.id.btnToday);
+        LinearLayout btn7DaysAgo = view.findViewById(R.id.btn7DaysAgo);
+        LinearLayout btn1MonthAgo = view.findViewById(R.id.btn1MonthAgo);
+        LinearLayout btn6MonthsAgo = view.findViewById(R.id.btn6MonthsAgo);
+        LinearLayout btnAllTime = view.findViewById(R.id.btnAllTime);
         LinearLayout btnSingleDay = view.findViewById(R.id.btnSingleDay);
         LinearLayout btnDateRange = view.findViewById(R.id.btnDateRange);
         LinearLayout btnClear = view.findViewById(R.id.btnClear);
@@ -77,6 +89,42 @@
             dismiss();
         });
 
+        btn7DaysAgo.setOnClickListener(v -> {
+            currentFilterType = "7_days";
+            updateCheckIcons();
+            if (listener != null) {
+                listener.on7DaysAgoSelected();
+            }
+            dismiss();
+        });
+
+        btn1MonthAgo.setOnClickListener(v -> {
+            currentFilterType = "1_month";
+            updateCheckIcons();
+            if (listener != null) {
+                listener.on1MonthAgoSelected();
+            }
+            dismiss();
+        });
+
+        btn6MonthsAgo.setOnClickListener(v -> {
+            currentFilterType = "6_months";
+            updateCheckIcons();
+            if (listener != null) {
+                listener.on6MonthsAgoSelected();
+            }
+            dismiss();
+        });
+
+        btnAllTime.setOnClickListener(v -> {
+            currentFilterType = "all_time";
+            updateCheckIcons();
+            if (listener != null) {
+                listener.onAllTimeSelected();
+            }
+            dismiss();
+        });
+
         btnSingleDay.setOnClickListener(v -> showSingleDayPicker());
 
         tvSingleDayDate.setOnClickListener(v -> showSingleDayPicker());
@@ -189,6 +237,18 @@
 
     private void updateCheckIcons() {
         ivTodayCheck.setVisibility("today".equals(currentFilterType) ? View.VISIBLE : View.GONE);
+        if (iv7DaysCheck != null) {
+            iv7DaysCheck.setVisibility("7_days".equals(currentFilterType) ? View.VISIBLE : View.GONE);
+        }
+        if (iv1MonthCheck != null) {
+            iv1MonthCheck.setVisibility("1_month".equals(currentFilterType) ? View.VISIBLE : View.GONE);
+        }
+        if (iv6MonthsCheck != null) {
+            iv6MonthsCheck.setVisibility("6_months".equals(currentFilterType) ? View.VISIBLE : View.GONE);
+        }
+        if (ivAllTimeCheck != null) {
+            ivAllTimeCheck.setVisibility("all_time".equals(currentFilterType) ? View.VISIBLE : View.GONE);
+        }
         ivSingleDayCheck.setVisibility("single".equals(currentFilterType) ? View.VISIBLE : View.GONE);
         ivDateRangeCheck.setVisibility("range".equals(currentFilterType) ? View.VISIBLE : View.GONE);
     }
